import { Scalar } from '../nodes/Scalar.js';
import { foldFlowLines, FOLD_QUOTED, FOLD_FLOW, FOLD_BLOCK } from './foldFlowLines.js';

const getFoldOptions = (ctx, isBlock) => ({
    indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
    lineWidth: ctx.options.lineWidth,
    minContentWidth: ctx.options.minContentWidth
});
// Also checks for lines starting with %, as parsing the output as YAML 1.1 will
// presume that's starting a new document.
const containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
    if (!lineWidth || lineWidth < 0)
        return false;
    const limit = lineWidth - indentLength;
    const strLen = str.length;
    if (strLen <= limit)
        return false;
    for (let i = 0, start = 0; i < strLen; ++i) {
        if (str[i] === '\n') {
            if (i - start > limit)
                return true;
            start = i + 1;
            if (strLen - start <= limit)
                return false;
        }
    }
    return true;
}
function doubleQuotedString(value, ctx) {
    const json = JSON.stringify(value);
    if (ctx.options.doubleQuotedAsJSON)
        return json;
    const { implicitKey } = ctx;
    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
    let str = '';
    let start = 0;
    for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
        if (ch === ' ' && json[i + 1] === '\\' && json[i + 2] === 'n') {
            // space before newline needs to be escaped to not be folded
            str += json.slice(start, i) + '\\ ';
            i += 1;
            start = i;
            ch = '\\';
        }
        if (ch === '\\')
            switch (json[i + 1]) {
                case 'u':
                    {
                        str += json.slice(start, i);
                        const code = json.substr(i + 2, 4);
                        switch (code) {
                            case '0000':
                                str += '\\0';
                                break;
                            case '0007':
                                str += '\\a';
                                break;
                            case '000b':
                                str += '\\v';
                                break;
                            case '001b':
                                str += '\\e';
                                break;
                            case '0085':
                                str += '\\N';
                                break;
                            case '00a0':
                                str += '\\_';
                                break;
                            case '2028':
                                str += '\\L';
                                break;
                            case '2029':
                                str += '\\P';
                                break;
                            default:
                                if (code.substr(0, 2) === '00')
                                    str += '\\x' + code.substr(2);
                                else
                                    str += json.substr(i, 6);
                        }
                        i += 5;
                        start = i + 1;
                    }
                    break;
                case 'n':
                    if (implicitKey ||
                        json[i + 2] === '"' ||
                        json.length < minMultiLineLength) {
                        i += 1;
                    }
                    else {
                        // folding will eat first newline
                        str += json.slice(start, i) + '\n\n';
                        while (json[i + 2] === '\\' &&
                            json[i + 3] === 'n' &&
                            json[i + 4] !== '"') {
                            str += '\n';
                            i += 2;
                        }
                        str += indent;
                        // space after newline needs to be escaped to not be folded
                        if (json[i + 2] === ' ')
                            str += '\\';
                        i += 1;
                        start = i + 1;
                    }
                    break;
                default:
                    i += 1;
            }
    }
    str = start ? str + json.slice(start) : json;
    return implicitKey
        ? str
        : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx, false));
}
function singleQuotedString(value, ctx) {
    if (ctx.options.singleQuote === false ||
        (ctx.implicitKey && value.includes('\n')) ||
        /[ \t]\n|\n[ \t]/.test(value) // single quoted string can't have leading or trailing whitespace around newline
    )
        return doubleQuotedString(value, ctx);
    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
    const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&\n${indent}`) + "'";
    return ctx.implicitKey
        ? res
        : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function quotedString(value, ctx) {
    const { singleQuote } = ctx.options;
    let qs;
    if (singleQuote === false)
        qs = doubleQuotedString;
    else {
        const hasDouble = value.includes('"');
        const hasSingle = value.includes("'");
        if (hasDouble && !hasSingle)
            qs = singleQuotedString;
        else if (hasSingle && !hasDouble)
            qs = doubleQuotedString;
        else
            qs = singleQuote ? singleQuotedString : doubleQuotedString;
    }
    return qs(value, ctx);
}
// The negative lookbehind avoids a polynomial search,
// but isn't supported yet on Safari: https://caniuse.com/js-regexp-lookbehind
let blockEndNewlines;
try {
    blockEndNewlines = new RegExp('(^|(?<!\n))\n+(?!\n|$)', 'g');
}
catch {
    blockEndNewlines = /\n+(?!\n|$)/g;
}
function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
    const { blockQuote, commentString, lineWidth } = ctx.options;
    // 1. Block can't end in whitespace unless the last line is non-empty.
    // 2. Strings consisting of only whitespace are best rendered explicitly.
    if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
        return quotedString(value, ctx);
    }
    const indent = ctx.indent ||
        (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');
    const literal = blockQuote === 'literal'
        ? true
        : blockQuote === 'folded' || type === Scalar.BLOCK_FOLDED
            ? false
            : type === Scalar.BLOCK_LITERAL
                ? true
                : !lineLengthOverLimit(value, lineWidth, indent.length);
    if (!value)
        return literal ? '|\n' : '>\n';
    // determine chomping from whitespace at value end
    let chomp;
    let endStart;
    for (endStart = value.length; endStart > 0; --endStart) {
        const ch = value[endStart - 1];
        if (ch !== '\n' && ch !== '\t' && ch !== ' ')
            break;
    }
    let end = value.substring(endStart);
    const endNlPos = end.indexOf('\n');
    if (endNlPos === -1) {
        chomp = '-'; // strip
    }
    else if (value === end || endNlPos !== end.length - 1) {
        chomp = '+'; // keep
        if (onChompKeep)
            onChompKeep();
    }
    else {
        chomp = ''; // clip
    }
    if (end) {
        value = value.slice(0, -end.length);
        if (end[end.length - 1] === '\n')
            end = end.slice(0, -1);
        end = end.replace(blockEndNewlines, `$&${indent}`);
    }
    // determine indent indicator from whitespace at value start
    let startWithSpace = false;
    let startEnd;
    let startNlPos = -1;
    for (startEnd = 0; startEnd < value.length; ++startEnd) {
        const ch = value[startEnd];
        if (ch === ' ')
            startWithSpace = true;
        else if (ch === '\n')
            startNlPos = startEnd;
        else
            break;
    }
    let start = value.substring(0, startNlPos < startEnd ? startNlPos + ": "ანგარიში",
  "settingsSelectiveSyncQuotaStatusNoAccount": "დაკავშირებული ანგარიში არ გაქვთ. ანგარიშის დასაკავშირებლად აირჩიეთ „ანგარიშის დამატება“ და შედით სისტემაში.",
  "settingsTabHint": "ახდენს ნავიგაციას ჩანართზე",
  "settingsToggleOn": "ჩართვა",
  "settingsToggleOff": "გამორთვა",
  "settingsAccountVaultAutolock": "პირადი სეიფი",
  "settingsAccountVault20minutes": "20 წუთი",
  "settingsAccountVault1hour": "1 საათი",
  "settingsAccountVault2hours": "2 საათი",
  "settingsAccountVault4hours": "4 საათი",
  "settingsAccountVaultNotification": "უსაფრთხოების მიზნებისთვის თქვენი პერსონალური სეიფი ავტომატურად დაიბლოკება, როდესაც მას აქტიურად არ იყენებთ.",
  "settingsAccountVaultLockAfterText": "პირადი სეიფის დაბლოკვა:",
  "settingsAccountVaultAccessibilityLabel": "პირადი სეიფის ჩაკეტვა ამ დროის შემდეგ.",
  "settingsAccountProfilePictureLabel": "პროფილის სურათი",
  "settingsUnlinkConfirmDialogPrimary": "გსურთ, გაწყვიტოთ ანგარიშის კავშირი ამ კომპიუტერთან?",
  "settingsUnlinkConfirmDialogOk": "ანგარიშის კავშირის გაწყვეტა",
  "settingsUnlinkSurveyPrompt": "გვაცნობეთ, რატომ გადაწყვიტეთ თქვენი მოწყობილობის მიბმის შეწყვეტა.",
  "settingsUnlinkSurveyTitle": "ვწუხვართ, რომ გვტოვებთ",
  "settingsUnlinkSurveyCategoryReinstalling": "ჩემი მოწყობილობის პარამეტრების ხელახლა დაყენებას ან ახალი მოწყობილობის ყიდვას ვაპირებ",
  "settingsUnlinkSurveyCategoryFixingIssue": "პრობლემის გადაჭრას ვცდილობ",
  "settingsUnlinkSurveyCategoryLeavingOnedrive": "მე გავდივარ OneDrive-იდან და სხვა ონლაინ-საცავის სერვისზე გადავდივარ",
  "settingsUnlinkSurveyCategoryOther": "სხვა",
  "settingsStopSyncConfirmDialogTeamsiteOk": "სინქრონიზაციის შეწყვეტა",
  "commonOkButton": "კარგი",
  "commonCancelButton": "გაუქმება",
  "commonContinueButton": "გაგრძელება",
  "settingsAutoSaveImportCheckboxNew": "ავტომატურად შეინახოს ფოტოები და ვიდეოები OneDrive-ში, როცა კამერას, ტელეფონს ან სხვა მოწყობილებას დავაკავშირებ პერსონალურ კომპიუტერს.",
  "settingsAutoSavePhotosVideosNew": "შეინახოს ფოტოები და ვიდეოები მოწყობილობებიდან",
  "settingsAutoSaveScreenshotsCheckboxNew": "ჩემ მიერ გადაღებული ეკრანის ანაბეჭდები შეინახოს OneDrive-ში",
  "settingsSyncBackupText": "შექმენით თქვენი სამუშაო დაფის, დოკუმენტებისა და სურათების საქაღალდეების სარეზერვო ასლები OneDrive-ზე, რომ ისინი დაცული და ხელმისაწვდომი იყოს სხვა მოწყობილობებზეც.",
  "settingsBackupMoveWindowLaunchButton": "მარქაფის მართვა",
  "settingsUsqNearing": "თქვენი საცავი თითქმის სავსეა",
  "settingsUsqFull": "თქვენი საცავი სავსეა",
  "freStartSyncButton": "სინქრონიზაცი