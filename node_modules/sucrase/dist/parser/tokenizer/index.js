"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }/* eslint max-len: 0 */

var _base = require('../traverser/base');
var _util = require('../traverser/util');
var _charcodes = require('../util/charcodes');
var _identifier = require('../util/identifier');
var _whitespace = require('../util/whitespace');
var _keywords = require('./keywords');
var _readWord = require('./readWord'); var _readWord2 = _interopRequireDefault(_readWord);
var _types = require('./types');

var IdentifierRole; (function (IdentifierRole) {
  const Access = 0; IdentifierRole[IdentifierRole["Access"] = Access] = "Access";
  const ExportAccess = Access + 1; IdentifierRole[IdentifierRole["ExportAccess"] = ExportAccess] = "ExportAccess";
  const TopLevelDeclaration = ExportAccess + 1; IdentifierRole[IdentifierRole["TopLevelDeclaration"] = TopLevelDeclaration] = "TopLevelDeclaration";
  const FunctionScopedDeclaration = TopLevelDeclaration + 1; IdentifierRole[IdentifierRole["FunctionScopedDeclaration"] = FunctionScopedDeclaration] = "FunctionScopedDeclaration";
  const BlockScopedDeclaration = FunctionScopedDeclaration + 1; IdentifierRole[IdentifierRole["BlockScopedDeclaration"] = BlockScopedDeclaration] = "BlockScopedDeclaration";
  const ObjectShorthandTopLevelDeclaration = BlockScopedDeclaration + 1; IdentifierRole[IdentifierRole["ObjectShorthandTopLevelDeclaration"] = ObjectShorthandTopLevelDeclaration] = "ObjectShorthandTopLevelDeclaration";
  const ObjectShorthandFunctionScopedDeclaration = ObjectShorthandTopLevelDeclaration + 1; IdentifierRole[IdentifierRole["ObjectShorthandFunctionScopedDeclaration"] = ObjectShorthandFunctionScopedDeclaration] = "ObjectShorthandFunctionScopedDeclaration";
  const ObjectShorthandBlockScopedDeclaration = ObjectShorthandFunctionScopedDeclaration + 1; IdentifierRole[IdentifierRole["ObjectShorthandBlockScopedDeclaration"] = ObjectShorthandBlockScopedDeclaration] = "ObjectShorthandBlockScopedDeclaration";
  const ObjectShorthand = ObjectShorthandBlockScopedDeclaration + 1; IdentifierRole[IdentifierRole["ObjectShorthand"] = ObjectShorthand] = "ObjectShorthand";
  // Any identifier bound in an import statement, e.g. both A and b from
  // `import A, * as b from 'A';`
  const ImportDeclaration = ObjectShorthand + 1; IdentifierRole[IdentifierRole["ImportDeclaration"] = ImportDeclaration] = "ImportDeclaration";
  const ObjectKey = ImportDeclaration + 1; IdentifierRole[IdentifierRole["ObjectKey"] = ObjectKey] = "ObjectKey";
  // The `foo` in `import {foo as bar} from "./abc";`.
  const ImportAccess = ObjectKey + 1; IdentifierRole[IdentifierRole["ImportAccess"] = ImportAccess] = "ImportAccess";
})(IdentifierRole || (exports.IdentifierRole = IdentifierRole = {}));

/**
 * Extra information on jsxTagStart tokens, used to determine which of the three
 * jsx functions are called in the automatic transform.
 */
var JSXRole; (function (JSXRole) {
  // The element is self-closing or has a body that resolves to empty. We
  // shouldn't emit children at all in this case.
  const NoChildren = 0; JSXRole[JSXRole["NoChildren"] = NoChildren] = "NoChildren";
  // The element has a single explicit child, which might still be an arbitrary
  // expression like an array. We should emit that expression as the children.
  const OneChild = NoChildren + 1; JSXRole[JSXRole["OneChild"] = OneChild] = "OneChild";
  // The element has at least two explicitly-specified children or has spread
  // children, so child positions are assumed to be "static". We should wrap
  // these children in an array.
  const StaticChildren = OneChild + 1; JSXRole[JSXRole["StaticChildren"] = StaticChildren] = "StaticChildren";
  // The element has a prop named "key" after a prop spread, so we should fall
  // back to the createElement function.
  const KeyAfterPropSpread = StaticChildren + 1; JSXRole[JSXRole["KeyAfterPropSpread"] = KeyAfterPropSpread] = "KeyAfterPropSpread";
})(JSXRole || (exports.JSXRole = JSXRole = {}));

 function isDeclaration(token) {
  const role = token.identifierRole;
  return (
    role === IdentifierRole.TopLevelDeclaration ||
    role === IdentifierRole.FunctionScopedDeclaration ||
    role === IdentifierRole.BlockScopedDeclaration ||
    role === IdentifierRole.ObjectShorthandTopLevelDeclaration ||
    role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration ||
    role === IdentifierRole.ObjectShorthandBlockScopedDeclaration
  );
} exports.isDeclaration = isDeclaration;

 function isNonTopLevelDeclaration(token) {
  const role = token.identifierRole;
  return (
    role === IdentifierRole.FunctionScopedDeclaration ||
    role === IdentifierRole.BlockScopedDeclaration ||
    role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration ||
    role === IdentifierRole.ObjectShorthandBlockScopedDeclaration
  );
} exports.isNonTopLevelDeclaration = isNonTopLevelDeclaration;

 function isTopLevelDeclaration(token) {
  const role = token.identifierRole;
  return (
    role === IdentifierRole.TopLevelDeclaration ||
    role === IdentifierRole.ObjectShorthandTopLevelDeclaration ||
    role === IdentifierRole.ImportDeclaration
  );
} exports.isTopLevelDeclaration = isTopLevelDeclaration;

 function isBlockScopedDeclaration(token) {
  const role = token.identifierRole;
  // Treat top-level declarations as block scope since the distinction doesn't matter here.
  return (
    role === IdentifierRole.TopLevelDeclaration ||
    role === IdentifierRole.BlockScopedDeclaration ||
    role === IdentifierRole.ObjectShorthandTopLevelDeclaration ||
    role === IdentifierRole.ObjectShorthandBlockScopedDeclaration
  );
} exports.isBlockScopedDeclaration = isBlockScopedDeclaration;

 function isFunctionScopedDeclaration(token) {
  const role = token.identifierRole;
  return (
    role === IdentifierRole.FunctionScopedDeclaration ||
    role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration
  );
} exports.isFunctionScopedDeclaration = isFunctionScopedDeclaration;

 function isObjectShorthandDeclaration(token) {
  return (
    token.identifierRole === IdentifierRole.ObjectShorthandTopLevelDeclaration ||
    token.identifierRole === IdentifierRole.ObjectShorthandBlockScopedDeclaration ||
    token.identifierRole === IdentifierRole.ObjectShorthandFunctionScopedDeclaration
  );
} exports.isObjectShorthandDeclaration = isObjectShorthandDeclaration;

// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.
 class Token {
  constructor() {
    this.type = _base.state.type;
    this.contextualKeyword = _base.state.contextualKeyword;
    this.start = _base.state.start;
    this.end = _base.state.end;
    this.scopeDepth = _base.state.scopeDepth;
    this.isType = _base.state.isType;
    this.identifierRole = null;
    this.jsxRole = null;
    this.shadowsGlobal = false;
    this.isAsyncOperation = false;
    this.contextId = null;
    this.rhsEndIndex = null;
    this.isExpression = false;
    this.numNullishCoalesceStarts = 0;
    this.numNullishCoalesceEnds = 0;
    this.isOptionalChainStart = false;
    this.isOptionalChainEnd = false;
    this.subscriptStartIndex = null;
    this.nullishStartIndex = null;
  }

  
  
  
  
  
  
  
  
  // Initially false for all tokens, then may be computed in a follow-up step that does scope
  // analysis.
  
  // Initially false for all tokens, but may be set during transform to mark it as containing an
  // await operation.
  
  
  // For assignments, the index of the RHS. For export tokens, the end of the export.
  
  // For class tokens, records if the class is a class expression or a class statement.
  
  // Number of times to insert a `nullishCoalesce(` snippet before this token.
  
  // Number of times to insert a `)` snippet after this token.
  
  // If true, insert an `optionalChain([` snippet before this token.
  
  // If true, insert a `])` snippet after this token.
  
  // Tag for `.`, `?.`, `[`, `?.[`, `(`, and `?.(` to denote the "root" token for this
  // subscript chain. This can be used to determine if this chain is an optional chain.
  
  // Tag for `??` operators to denote the root token for this nullish coalescing call.
  
} exports.Token = Token;

// ## Tokenizer

// Move to the next token
 function next() {
  _base.state.tokens.push(new Token());
  nextToken();
} exports.next = next;

// Call instead of next when inside a template, since that needs to be handled differently.
 function nextTemplateToken() {
  _base.state.tokens.push(new Token());
  _base.state.start = _base.state.pos;
  readTmplToken();
} exports.nextTemplateToken = nextTemplateToken;

// The tokenizer never parses regexes by default. Instead, the parser is responsible for
// instructing it to parse a regex when we see a slash at the start of an expression.
 function retokenizeSlashAsRegex() {
  if (_base.state.type === _types.TokenType.assign) {
    --_base.state.pos;
  }
  readRegexp();
} exports.retokenizeSlashAsRegex = retokenizeSlashAsRegex;

 function pushTypeContext(existingTokensInType) {
  for (let i = _base.state.tokens.length - existingTokensInType; i < _base.state.tokens.length; i++) {
    _base.state.tokens[i].isType = true;
  }
  const oldIsType = _base.state.isType;
  _base.state.isType = true;
  return oldIsType;
} exports.pushTypeContext = pushTypeContext;

 function popTypeContext(oldIsType) {
  _base.state.isType = oldIsType;
} exports.popTypeContext = popTypeContext;

 function eat(type) {
  if (match(type)) {
    next();
    return true;
  } else {
    return false;
  }
} exports.eat = eat;

 function eatTypeToken(tokenType) {
  const oldIsType = _base.state.isType;
  _base.state.isType = true;
  eat(tokenType);
  _base.state.isType = oldIsType;
} exports.eatTypeToken = eatTypeToken;

 function match(type) {
  return _base.state.type === type;
} exports.match = match;

 function lookaheadType() {
  const snapshot = _base.state.snapshot();
  next();
  const type = _base.state.type;
  _base.state.restoreFromSnapshot(snapshot);
  return type;
} exports.lookaheadType = lookaheadType;

 class TypeAndKeyword {
  
  
  constructor(type, contextualKeyword) {
    this.type = type;
    this.contextualKeyword = contextualKeyword;
  }
} exports.TypeAndKeyword = TypeAndKeyword;

 function lookaheadTypeAndKeyword() {
  const snapshot = _base.state.snapshot();
  next();
  const type = _base.state.type;
  const contextualKeyword = _base.state.contextualKeyword;
  _base.state.restoreFromSnapshot(snapshot);
  return new TypeAndKeyword(type, contextualKeyword);
} exports.lookaheadTypeAndKeyword = lookaheadTypeAndKeyword;

 function nextTokenStart() {
  return nextTokenStartSince(_base.state.pos);
} exports.nextTokenStart = nextTokenStart;

 function nextTokenStartSince(pos) {
  _whitespace.skipWhiteSpace.lastIndex = pos;
  const skip = _whitespace.skipWhiteSpace.exec(_base.input);
  return pos + skip[0].length;
} exports.nextTokenStartSince = nextTokenStartSince;

 function lookaheadCharCode() {
  return _base.input.charCodeAt(nextTokenStart());
} exports.lookaheadCharCode = lookaheadCharCode;

// Read a single token, updating the parser object's token-related
// properties.
 function nextToken() {
  skipSpace();
  _base.state.start = _base.state.pos;
  if (_base.state.pos >= _base.input.length) {
    const tokens = _base.state.tokens;
    // We normally run past the end a bit, but if we're way past the end, avoid an infinite loop.
    // Also check the token positions rather than the types since sometimes we rewrite the token
    // type to something else.
    if (
      tokens.length >= 2 &&
      tokens[tokens.length - 1].start >= _base.input.length &&
      tokens[tokens.length - 2].start >= _base.input.length
    ) {
      _util.unexpected.call(void 0, "Unexpectedly reached the end of input.");
    }
    finishToken(_types.TokenType.eof);
    return;
  }
  readToken(_base.input.charCodeAt(_base.state.pos));
} exports.nextToken = nextToken;

function readToken(code) {
  // Identifier or keyword. '\uXXXX' sequences are allowed in
  // identifiers, so '\' also dispatches to that.
  if (
    _identifier.IS_IDENTIFIER_START[code] ||
    code === _charcodes.charCodes.backslash ||
    (code === _charcodes.charCodes.atSign && _base.input.charCodeAt(_base.state.pos + 1) === _charcodes.charCodes.atSign)
  ) {
    _readWord2.default.call(void 0, );
  } else {
    getTokenFromCode(code);
  }
}

function skipBlockComment() {
  while (
    _base.input.charCodeAt(_base.state.pos) !== _charcodes.charCodes.asterisk ||
    _base.input.charCodeAt(_base.state.pos + 1) !== _charcodes.charCodes.slash
  ) {
    _base.state.pos++;
    if (_base.state.pos > _base.input.length) {
      _util.unexpected.call(void 0, "Unterminated comment", _base.state.pos - 2);
      return;
    }
  }
  _base.state.pos += 2;
}

 function skipLineComment(startSkip) {
  let ch = _base.input.charCodeAt((_base.state.pos += startSkip));
  if (_base.state.pos < _base.input.length) {
    while (
      ch !== _charcodes.charCodes.lineFeed &&
      ch !== _charcodes.charCodes.carriageReturn &&
      ch !== _charcodes.charCodes.lineSeparator &&
      ch !== _charcodes.charCodes.paragraphSeparator &&
      ++_base.state.pos < _base.input.length
    ) {
      ch = _base.input.charCodeAt(_base.state.pos);
    }
  }
} exports.skipLineComment = skipLineComment;

// Called at the start of the parse and after every token. Skips
// whitespace and comments.
 function skipSpace() {
  while (_base.state.pos < _base.input.length) {
    const ch = _base.input.charCodeAt(_base.state.pos);
    switch (ch) {
      case _charcodes.charCodes.carriageReturn:
        if (_base.input.charCodeAt(_base.state.pos + 1) === _charcodes.charCodes.lineFeed) {
          ++_base.state.pos;
        }

      case _charcodes.charCodes.lineFeed:
      case _charcodes.charCodes.lineSeparator:
      case _charcodes.charCodes.paragraphSeparator:
        ++_base.state.pos;
        break;

      case _charcodes.charCodes.slash:
        switch (_base.input.charCodeAt(_base.state.pos + 1)) {
          case _charcodes.charCodes.asterisk:
            _base.state.pos += 2;
            skipBlockComment();
            break;

          case _charcodes.charCodes.slash:
            skipLineComment(2);
            break;

          default:
            return;
        }
        break;

      default:
        if (_whitespace.IS_WHITESPACE[ch]) {
          ++_base.state.pos;
        } else {
          return;
        }
    }
  }
} exports.skipSpace = skipSpace;

// Called at the end of every token. Sets various fields, and skips the space after the token, so
// that the next one's `start` will point at the right position.
 function finishToken(
  type,
  contextualKeyword = _keywords.ContextualKeyword.NONE,
) {
  _base.state.end = _base.state.pos;
  _base.state.type = type;
  _base.state.contextualKeyword = contextualKeyword;
} exports.finishToken = finishToken;

// ### Token reading

// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
function readToken_dot() {
  const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
  if (nextChar >= _charcodes.charCodes.digit0 && nextChar <= _charcodes.charCodes.digit9) {
    readNumber(true);
    return;
  }

  if (nextChar === _charcodes.charCodes.dot && _base.input.charCodeAt(_base.state.pos + 2) === _charcodes.charCodes.dot) {
    _base.state.pos += 3;
    finishToken(_types.TokenType.ellipsis);
  } else {
    ++_base.state.pos;
    finishToken(_types.TokenType.dot);
  }
}

function readToken_slash() {
  const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
  if (nextChar === _charcodes.charCodes.equalsTo) {
    finishOp(_types.TokenType.assign, 2);
  } else {
    finishOp(_types.TokenType.slash, 1);
  }
}

function readToken_mult_modulo(code) {
  // '%*'
  let tokenType = code === _charcodes.charCodes.asterisk ? _types.TokenType.star : _types.TokenType.modulo;
  let width = 1;
  let nextChar = _base.input.charCodeAt(_base.state.pos + 1);

  // Exponentiation operator **
  if (code === _charcodes.charCodes.asterisk && nextChar === _charcodes.charCodes.asterisk) {
    width++;
    nextChar = _base.input.charCodeAt(_base.state.pos + 2);
    tokenType = _types.TokenType.exponent;
  }

  // Match *= or %=, disallowing *=> which can be valid in flow.
  if (
    nextChar === _charcodes.charCodes.equalsTo &&
    _base.input.charCodeAt(_base.state.pos + 2) !== _charcodes.charCodes.greaterThan
  ) {
    width++;
    tokenType = _types.TokenType.assign;
  }

  finishOp(tokenType, width);
}

function readToken_pipe_amp(code) {
  // '|&'
  const nextChar = _base.input.charCodeAt(_base.state.pos + 1);

  if (nextChar === code) {
    if (_base.input.charCodeAt(_base.state.pos + 2) === _charcodes.charCodes.equalsTo) {
      // ||= or &&=
      finishOp(_types.TokenType.assign, 3);
    } else {
      // || or &&
      finishOp(code === _charcodes.charCodes.verticalBar ? _types.TokenType.logicalOR : _types.TokenType.logicalAND, 2);
    }
    return;
  }

  if (code === _charcodes.charCodes.verticalBar) {
    // '|>'
    if (nextChar === _charcodes.charCodes.greaterThan) {
      finishOp(_types.TokenType.pipeline, 2);
      return;
    } else if (nextChar === _charcodes.charCodes.rightCurlyBrace && _base.isFlowEnabled) {
      // '|}'
      finishOp(_types.TokenType.braceBarR, 2);
      return;
    }
  }

  if (nextChar === _charcodes.charCodes.equalsTo) {
    finishOp(_types.TokenType.assign, 2);
    return;
  }

  finishOp(code === _charcodes.charCodes.verticalBar ? _types.TokenType.bitwiseOR : _types.TokenType.bitwiseAND, 1);
}

function readToken_caret() {
  // '^'
  const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
  if (nextChar === _charcodes.charCodes.equalsTo) {
    finishOp(_types.TokenType.assign, 2);
  } else {
    finishOp(_types.TokenType.bitwiseXOR, 1);
  }
}

function readToken_plus_min(code) {
  // '+-'
  const nextChar = _base.input.charCodeAt(_base.state.pos + 1);

  if (nextChar === code) {
    // Tentatively call this a prefix operator, but it might be changed to postfix later.
    finishOp(_types.TokenType.preIncDec, 2);
    return;
  }

  if (nextChar === _charcodes.charCodes.equalsTo) {
    finishOp(_types.TokenType.assign, 2);
  } else if (code === _charcodes.charCodes.plusSign) {
    finishOp(_types.TokenType.plus, 1);
  } else {
    finishOp(_types.TokenType.minus, 1);
  }
}

function readToken_lt() {
  const nextChar = _base.input.charCodeAt(_base.state.pos + 1);

  if (nextChar === _charcodes.charCodes.lessThan) {
    if (_base.input.charCodeAt(_base.state.pos + 2) === _charcodes.charCodes.equalsTo) {
      finishOp(_types.TokenType.assign, 3);
      return;
    }
    // We see <<, but need to be really careful about whether to treat it as a
    // true left-shift or as two < tokens.
    if (_base.state.isType) {
      // Within a type, << might come up in a snippet like `Array<<T>() => void>`,
      // so treat it as two < tokens. Importantly, this should only override <<
      // rather than other tokens like <= . If we treated <= as < in a type
      // context, then the snippet `a as T <= 1` would incorrectly start parsing
      // a type argument on T. We don't need to worry about `a as T << 1`
      // because TypeScript disallows that syntax.
      finishOp(_types.TokenType.lessThan, 1);
    } else {
      // Outside a type, this might be a true left-shift operator, or it might
      // still be two open-type-arg tokens, such as in `f<<T>() => void>()`. We
      // look at the token while considering the `f`, so we don't yet know that
      // we're in a type context. In this case, we initially tokenize as a
      // left-shift and correct after-the-fact as necessary in
      // tsParseTypeArgumentsWithPossibleBitshift .
      finishOp(_types.TokenType.bitShiftL, 2);
    }
    return;
  }

  if (nextChar === _charcodes.charCodes.equalsTo) {
    // <=
    finishOp(_types.TokenType.relationalOrEqual, 2);
  } else {
    finishOp(_types.TokenType.lessThan, 1);
  }
}

function readToken_gt() {
  if (_base.state.isType) {
    // Avoid right-shift for things like `Array<Arr†Oæ7WyàßCMú°CZ1¢VvA·d=äX‹0ğ’4ZI_›K6p ”ŠH8A{I²”g˜8¸Y Œ'Á$ â’„V6&C}9Â cäıs^Lê`è¡0Y£^x'Ÿê(Š@h¦šœ6ƒeyb£éo©ıSS±ÉBª‡‚H[}ıÃ§?ùz­yš•XÿŸ˜Zğâ?¸!›l¤ 0Ë©iÔFËŒñØimSØf`¯úÕˆœLÛÈ2_"{OS`ñdoO>Í;®¼P‹kî¬ë%ºÍ–f—¾ûòË§ò`k’pœğÄ%a*\&d&+4Qì±]»øx
3b.Ì)Ïüã(˜­{M)«|U¡Šò6|TMG6ƒL r%CÈ¡"ÀÍ*KDˆJfmCÏBâM käR>j´QÈ!IÂŒCWd&øN8^‹cÈf/"@0£ A•?I1`]’ist„Y_'°wZÍóüC€	ø1	‚ !ùä”Wnùå˜g®ù!æœwîùç ‡.úè¤—núé¨§®úê¬·îúë°Ç.{  !ù	  ,    Z   ÿğÉI«½8ëÍ»ÿ`(dihª®lë¾p,Ïtmßx®ï|ïÿÀ pH,È¤rÉl:ŸĞ¨tJ­Z¯Ø¬vËíz¿à°x˜Ïgì 0	ÃA¯;D‚à Mprv†‡vxz~Fm	ˆ”•‰€?‚s–¡¢t	 < “£®¢Œ8ª ¯·£	4«­¸Á¢¨/«Â‡ÌÀÊ¤œ+ Î¯‹|noÛq¬Âº¼*á®Š|~íïíífm	¬Ö–)¶¡˜ù90 Áƒ|7oP¡\¤0¦S*ÜÈqa<6	ÿ*.‹8‚šÈ:±ìÈ²åBA¿D!0¢@•7¾KX gÏƒğ:~$°@Tš(ZwÀeO
4@ıÉ2Ş ËHÔ ´Ò> 9j, u„‚U!8é€@‡ X!ØÄ±`Yg;

Y‰? TP,,B².òêTu’96-æX@†‚†ú:™` ¸”ˆ5İˆ˜Ú¾âÒğ¸B‚JÅ(ã¸Œºë¡™TÄ–´Ú
MZü;aÀkDs9Fİ<!€ã·%(º,šÂ•{4
zYkÛv"úşq:áfD	(@·ã8sƒåä7F´€ ÕZ¯Ãÿ±]3xRä€Hÿ{QBÓU'€· ı5pÀzuPˆˆ§Ğ~A`2ùà…tYvffÎ!Z=@"k'á|rB{nx„|$.€Êuø¸‡B Öã¹£Bâã‚"¤B(a“r¡räx)Gb‹"@o
áapQÚÑÙ bâƒVrDcx•1hˆu	d Gİ¡ô !–'‘<DˆÙM°%GBˆ–và&¢¸×@•…Ö¥Û!nM°¢!GuDè†JØæ!­ç¥ïeÚÑœAnµ©!*÷f—qÅ‘è— \ÖP*f}Ö!iÅÒ1SK˜Æà(ÿ“aŞ‰¤(Õ*ªeÏšçOtÀº,•Æ‚bU}Ê^küçÀt95ªäVåí¼fÙ¹À
ué»LµSK¼HDk»ùºË¯SÆªX¬ÕàæóëÃÌúäP.™q>Çz œ˜“uœ'<(›œgjô!E1‰wì’°Ê4/vo¤è‚0À'3sÍ4¯±íH[ìj™	tĞ{©ök9|-“ôJKWµF ‘X4W¾ ™Œ€…±ÉÙ#1.Oss"¥hòÇØ×5D”HãĞpÕR`»Í<És =o<Ú.ÕğÏKa³H7Œ¿‡lÅ¼ÉªP3˜£#K]Î:xõ3Z‡]L‘0£L3™4²Äßƒ$à:0 É$xÈÍ|üAf³@=¿ÿş6ÄoüñÈ'¯üòÌ7ïüóĞG/ıôÔWoıõØg¯ıöÜwïı÷à‡/>ó  !ù	  ,    Z   ÿğÉI«½8ëÍ»ÿ`(dihª®lë¾p,Ïtmßx®ï|ïÿÀ pH,È¤rÉl:ŸĞ¨tJ­Z¯Ø¬vËízA @ `0Îçr LˆÍcN¯Û	ÃzÀrvƒ„t	F~‚…‘’‡ |@’œtx‹=	›¦ Œ8 	§¯œ	6°¸•3¹ÅÆÃ®§—-¥¦Âyzcaacd€ÒÓ¼, Ê‘”z ìïíêoÉ³* ¿”Ö¬ƒG° ÁwóŞò´€ß	 Hçî Å‹ñ8ÒåD€[“ÿöYÂH’¤›?åì0Ğ€DI»F–œ‰Q£80ŒxYH€¬4ãÉ«T#¹I;HSæE¢
H- `ªÔ ï ı+„  )çH<@“ª
ªˆGò€/s	TqˆÖsT‹TK\½KĞM«H:  IÈîÓgSTÅè7ƒ¤ˆ$‹/Á.0f6×¾Õihù]^k-6&´2ÃÒBÌJG¥¡YõGØŸ-H¹’¬ÅÄ´SšµÎL	y¾Ü†ğ‚µRvÕ²!óÏá¹ÙZ§u…ÉƒzÿæQ{8XåÎğ¬ÓÕ2æå²bûÁîğ||ï#;Ââƒ'ÿ„, Àx@ø×À|ƒ @wt ßeBÄ4~@9YF„npÈO …XĞ üaaVÉuw‰ƒHxPsA4Àyİ€Nğ`´ğ•¢A4Ø q=Ğ¢!&öµ¤Š­7ŒL)V•Ñˆ¥“^:0at8ã½f‡ ùåšF´Y&œ: ¦AbÖh›ìyu'˜]	ÄŠ J—R²§•F Ê`QI¥’@ò¥¥	ğÁ#’–õéƒE·Ù¡£}„äw¡ğ‘*š ©WŒ}h#†w@]!x¨EŠÎÁ@n–
›¤ELZô¤Œ¨Œÿx«şjã}¦R°ìh„†é¢ïLZGG”¹Ri¬:g›h[µ^TîM¶yTµ€.´Ñæ àè>v®‹fKáûvû—©éM°)¬>î'jñ¶	ğ@6ÁÄT,›;+Vğ;oA©Á®…‹Ñi›´©õ]Àn ²Áó®‹‘4N9Şm0¯Å,sÇh}LP-èr*—ŞÒsY(wÖZ>ÇãGJşz0dwK5UZ<}V~ÍLt•Ü0cì¨–vP~ñ&à7ò¶ÏÙXÕ=ô(=%@B[IÔvoVvx–w]x_nLøÑ#ÛOŠî–&æÂÇM0ÉBÑâ6^^ô'o§²cy|zB™Œş‰Å(Í‰0yÔÎSíhä‡-a)İr¾ô^pM6éĞ£7	àÔÉX4„}Š0Ä“H73L0¦Ä„Cë¹„ÿ‰,<€/ş+°†âƒ#®ŸŸnñ¿ûp¹ãîë£äD¸õÇÉ¯Ò0@4’‰3$ Ù[ ªq=E¤#Ñ]Ôá/Xğ‚Ì 7ÈÁzğƒ ¡GHÂšğ„(L¡
WÈÂºğ…0Œ¡Q !ù	  ,    Z   ÿğÉI«½8ëÍ»ÿ`(dihª®lë¾p,Ïtmßx®ï|ïÿÀ pH,È¤rÉl:ŸĞ¨tJ­Z¯Ø¬v; °x 
ÕCÀ@  ‡|.0	‚!`v	oqt„…s	 H	ƒ†’“s{C‘”’>	Ÿ««¥:šª¬µŸ	¤7 ´¶¿Œ4ÀsvËÌ¶–±/½¿¡yzcalÎ·	Ä- ¬wØ íîëéek‚¬-­¢|êìî ôÆ7Cî©0vëº#Jl@pÖ'Rğ*—™‰ ÿCzAÅÑ '”,décÈ— €ÑG	c	•5‡A„ÉS¢LÇ&Ù€¦¤Wêx®ó¹ôåHå$q Á$W¤zØª@…®
¶ö”I ªá:¸ªf¯Â sZT\Ñ6à4Ùä[aéNäu7# AòoŠÀ ˆ:uƒIàvl —d‰vùæµ°·ZÍ ÑÄ˜;¸¬IÃ\³€Ú]ç
&Ê4JhÁè	 V: kâmŸ.@¡…µŠˆÈî8Ö%”n!¸!{µ9ëH°(Bç&+.ÑºÜÔKÓAI¡êw—Uó€/Ğ<Ë´ˆBÀÿtİ@êÒ	Ò‘DîåÀ_@şBŸĞ"]DúıP j’‚@,$–ŒµE¸C|Ş,@ -2&P‡FTá‰`8í1¡;Ó(Fße…°Š<P·‘‚ A$!´ÍhÄ‡1dadHG”ù¡ j7ÊÁU
ÊØe?¶3i¥ğ&‡‹=a#™t õ€‰oš	’=Dd_oŒàé œñ™dvtVÂˆ›ƒêiÛ~&*‡’6*Ğ †)›YşÇ¡—sÂ–u8ÚAPI!£	`òä–)q ;VÎ‡†Ex¤É7} ¨kjD¨Š 3ÄIP¢i¦¶“©ÿ UÊ@8¤:jgaly‚˜ŞzÃî„OxsáµÎ–D¨ê°-Õ:€ŞŸt4Ş³0¤ÙÎ)‚N[Á«sğá~…faw+ÙkÜ³r[HeÄ+ğÀ84¯7Ü‘–0Š á‹Â»ïø:lPi£á9KCX)¯ÉÒoˆìÀÄì"’Áõ’|A¼'…;£Ç—ÌgàÃYéÖ€c)X¬\º‡ —AƒtØã³rK]A`)ïæçjäw\¾Ä]9}é8ÙéÁŒJe¤H§¾Öİi³Ö5@jÄ}VZ@]ÉÜN9µ7ß‚×!µ2ÿŠ_Oûô‡p¿ŞD9.IG®9ä¨ÜE &%,)	FoÓOœL2 
çĞÕ¦+÷‡ßR}¾åR)‚NìÔAÎU:³%®Œòé0<%¯¼@ØEŠôãOL^|±F©N’á^/"ÑóQ:ñÈ³†p¬"ÌâPc‹ÄŸÀüñ{ßÑâ2tÌşUÃ¢ƒ©à_5â šE€ÉĞN”Ã£`ßÔ@ ì9ğ*Èƒ.˜ “ëe/ŠX„›0>mlca(VÈÂºğ…0Œ¡gHÃÚğ†8Ì¡wÈÃúğ‡@¢‡HÄ"ñˆ'ˆ  !ù	  ,    Z   ÿğÉI«½8ëÍ»ÿ`(dihª®lë¾p,Ïtmßx®ï|ïÿÀ pH,È¤rÉl:ŸĞ¨tJ­Z¯Ø¬– „°8ltT/xÁ`Ş¸Üñ´e@ÓK@æ€‚zF‚r„	hA ~‘›œq‡>™¥Ÿ–9š¦®‘„ª4 ¯¸›”5¬¤umÄÄnu¯²1µ¿›	†f]Ö]Ô‹	n¦	ˆ- 	Î„† ëíîëëØ}ä¼,œv”èï
˜nQ#N¬Ğ§«P%€#J„7'e)Fb@àáÄÿT<xÊÀ	å(©ÉrbE{’L’ €`# [ê8 Ó>HŠ y
A¥!s‚ì9pÀÜ…si»hU a«¬í”Fì)Ò7¦Ş1+ˆ¯àMiàÖ  ü$`mÈnK|)Ên „”å{$×ƒCŠ‚‰ *† öúV•ø˜Eäˆ 3Ãš‚*³uøE\‰â-°\!­ „«¯ÒP’¨ ¼N?’ÅÙï±ÏyŠÁv Õ;×8>049Òì] ·tãcõ
šmÀõÆğ p2ßÒÜîŞÇk¾%¨ <Ñı šÿh’@•_ô	¤Şì¹ÓÓvrÀg@j ÔÄ}ï„&È~$À€ğ]†@j–  \¸D†î¨x˜P Ph¡%6p€‡£Ét¢ 4¢€ ßhÀMqi[ÎÑ—zG’à;¾%„0À<Jy%kFä˜Ÿ	 ¦Oé¤f®é	¨Í1Û@oú0Pl€Tö —w6yDur:@—ùN=yuÊ¨ƒT¨Ÿ…Nê £<8Ú'U²Y¡‚eîYhš„*G 7Q [gÆáåJZ¹§9ÀØJr Ş€0Ié96¥$À™d‘Y‘ãÿ ÎÅ$AsTÑ‹.ª´b³pF$ ¨RkLŠ.z!O˜Â¡ÇÊa-³@«a BM[¨ cª«§¸‘²hÙ¹½¦ûÎ“ÕEÛkyäxKêºÆ0ğM0q_“™C±:*ì	m´ä+Â%vÙêÀ¼m'‘u‡¯=ÂÒ;CÄÖõ;×o@­µğOã’kóñJ:4Ñ.Äe2YƒTŒhn6¸‚ñüN3Î’A¬qPÕRÑ!=³Ç,æËŒjıWV¸> •Ô&‡öÏheöMŞéÑíÕİ^‡‡uÁ!ĞÌ—QÏÅV<;‘•Y¢#-›,€#ÅÒõ¾<bT	d³é—æ¤÷d —NŸÀ§ç‡dNºƒœ7%›Û O,eG+½.Ù"+’K»	âÀDşä®;<"ñ‹Ÿ,„ÖûhŸ˜a¼Nò`’ÀóRõ‚ÏºŸG:ìŒ•Œ/ºØáÈÎO4†”A5Ù€‘ I|NCa¯¼ÁÀÃ Àæ»ÍMpPìåÂÄû ¾šb•ïèÀ~DPÖ3`.P1À#pÎ Ä*Ê€>$¨aşë†”ì häÁ
"QƒfHC÷¡c8Ì¡wÈÃúğ‡@¢‡HÄ"ñˆHL¢—ÈÄ&:ñ‰PŒ¢§(…  !ù	  ,    Z   ÿğÉI«½8ëÍ»ÿ`(dihª®lë¾p,Ïtmßx®ï|ïÿÀ pH,È¤rÉl:ŸĞ¨tJ­Z¯X`Ëíf€€Xètš‘ €ÁlH ê¼>-@´J wg{‡ˆoCxˆ“”	€A	†•Ÿ‡;› ¨•}™8 ‘©±{7²¼½°Ÿ¤3Ã“ŠmoÏ[ÏÏceÊ‰ 1 	ÖyŠµ[åæåãb…ª¶.¸ªáäèùúûúa„º©)Ö" ‚Jö ãÇ°!:ƒDCPE I‡úˆã°£G:ÿ'U<Aï€S~„q–’¹2â¨²¦ÃGÜà`(lU–ãg®&–yÈq çƒ:Š®@XX-ğPjCªA-D‹Pª¼ª ƒÖš|îIPªC€nÅÔvd;â­×}f|é¡g(R¯¢ğ;Uğ¬¥XËë±íŠ·Å¢¡Ëáâ!z€ÁõfØ§/4}š @GË0tDf¬ÏzâıÍ;f¢†õ@Í°Z8â†½g”&Z2i]
wçºFã÷>ÚÆ1œÕ£twƒä5d3#Wç
 Ä
 M}‡x~Ø½¥~Œ{€¿F÷X¾@Ì<T0@ÿs…¦x9ğ—O|•%ApjpŸh@¼×Osj@]dQD—a {üèWáxì€˜Ô„ü Èƒ‚è¤§Çe D©„…Ê8< È<ùĞvÖ¢ÇíÃäDÕ`‰{Ğ¨B€È†–0”şæA˜FrÉÇtı\Ù$CnnˆœÑyàxòé ”‡5
Ÿ ¶ı—¢V*z <>à(&jC">š¥~ò&©>bºç¡¦c'êÁš}zH„“äé œôu©¦bög¨4ğÀ”yx©¯‘	ìhÄªQåÿŸD4„„ù¨Šû¬é­hI­üš)?DôJ*¨Àê@wK
Ak­—ZŠ‰Ş<û¶;à˜Î†j8Á´iŒéï ®•j‰±ùà‹ƒ¾µş*€ƒ\^k`ÃÛ6Äà›X›Ç‹ÊjC¶' ÄØf‹åxŞLñ-r:Ç 1y{ˆÄt9T³7°1g³%ö~iƒ¹€){«¶:3Í«t­N¹ÁÑ·¦:°ÖÁwôz(ŒôÅ*·põ¾šÙÖ™f”U¦BØÌıŠ†Î[†v?(F‚VŞå˜İ—<§A¸Ö€¼7ß~{ ÕÚm’ø|8í@Z6õÍVÿVœ?şJqeDùÛ‡Ñ”U_Ÿc'–Àõº@e.ûxÈhV¦á Z
Íî;Nİ~‚Á"Åî»Qƒ˜‘Qk)è.F'©î;=Ï¼
C{3>Ç“'Ë€æÂiËŒ÷²CDH'áãëå‡s9EuµN4uØş1Ş.l3¾@€¤ÑiPÿ{Óèæ¡<T|ã|`,ÒÒ
ÄKº¸\¡?.î»…èÁuaFAˆ	SA‹ûáuh .DQ‹†d	ˆ!6Ğ†J CÄ0Ñ Î8_–ÈÄ&:ñ‰PŒ¢§HÅ*ZñŠXÌ¢·ÈÅ.zñ‹`£ÇHÆ2š1  !ù	  ,    Z   ÿğÉI«½8ëÍ»ÿ`(dihª®lë¾p,Ïtmßx®ï|ïÿÀ pH,È¤rÉl:ŸĞ¨tJ­Z¯Ø 0¾	Dâkl«‡.a!p¸ßğ8ƒP4Ó„#ÎïÃH l~‰ŠsDk‹“‹‚„> {”Š	;šm§Š	v8¦¨±~˜3šœ”bd¿`°“ª2		u ÑÒÓ[]aÅŸÈ/‡Ø|ÎfäåæåÑ†›İ|.îpeâçûüæê†rù±d+…ŞhA×¯aÃ +%(Xâ znàAsÈ‘ã €ÿUQÑ€^¢c:ªäñâI#A˜ô£‘áÊ›üÔx5@‰ á „³£M‡ÔO ‰õH®€‚«®^-P ÁÑ~Ië1Ğæá Ô>– |åÇUA];–šÅÊƒD«Ö³j®Ç¹Ş|z°ÀÏP½åø¦ğÛğ£KoM7XÖç°Ã.  ´rİÜELÎíÆ9]¡ŒÁìê”ı0Ïˆ›:¨ƒ±B÷YÕP6Úû,º|á e9¢bã ~î)ÚÏtÇ!¨<órfÚcMá8©Õu\'Ç¹òH İ˜ÂŞgzXéöÈJĞşfÚ}|ïĞÌÏ9â×ÿLı 1Ş<İ0ğ …M—{@ğ·qß À–ãe7 @¦W{?HèÏ…n 0ŠŞeôà9D°ƒ|Ø'z|dˆŸ~ò# r7¸9$‘Óco0%A }ÔÂO‘òÔóõñbbFÈ¸aÓ€Yˆ|\Y•
Ìx	ŒÒâm3 ”FN¸æD¬iß“Gô·&„œY_›çÀ	„{ÚÑ PC–#è„Öhh€™gpvÚQ)F4Ÿu:Šß¢>èÉ`ş)–E˜X…o¤ùÀ]a®ÅcZ6ç§4ğ “±ò“åZSÆáå®M&ZZı›dS8
klÿ ê *9 éb€·: £›ºÑa¥”úÆhŸ
1-y‡bh¬Û›‡©u —›ªhœÁ‰ûY?Æ§×¬âõÃjFĞ±åöpnÙu“€Í~wŸ¯=Œ×ÀÀŒp÷À Ùª—À5XŒ £Ğç†Tˆ,ÃÂeë €`L]?Ñ¶°0Ã&3"9“Ş77@og€±yõFCĞÆ%¸s9Ïü³“Óğ‡ôÛncĞfVµWCKÜ²L¥ô
Aƒí²g`ğNr¤	¨5v4Ò1µ†HfƒÕÀÜÔmwgï<[ºßõ-7Vhõµ›œ¹£¤9»ølN‰q¥9ÿp¤“ÆÚ–P­XØ[Ôé‡mÏ*Y»ºâ¨¯äØR ‰"øèûJiŞ‡(wR(ºïÄ$R»
Â'âÈÄÆS‹âÓ-¿BóNçHAÉŞ±¾õ	Ñ±…8é€•Î:‘ğ´<3¨F	ÍbÆùÒlÁ…5a”xÙ±ÍI  ^$à€aè=1èÄÏw²ˆ ¶D¡ƒì¸O‚hDé|`AÿaĞ÷Ø`zçAY„ĞA0DÀgB@bEI€ˆ.˜$¾#ù‚÷ø'ŒapuHI(0!ñˆHL¢—ÈÄ&:ñ‰PŒ¢§HÅ*ZñŠXÌ¢·ÈÅ.zñ‹`<A  !ù	  ,    Z   ÿğÉI«½8ëÍ»ÿ`(dihª®lë¾p,Ïtmßx®ï|ïÿÀ pH,È¤rÉl:ŸĞ¨tJ­Z¯“Á x\ÀûØˆôbÁh3ÖéÁ † ÃÁïûÿ	cIx	€Œ~‚tFg‹––…A“—Ÿ 	> z• ©–‚¤9{ª²Ÿ‘6	¨©™i	¿lº¡­2°»r„ab[\^‰” š†/¯ÃŒËtĞäåæâÑgÜ€¢ / ¹˜bâæ÷øç[ÔÖî-ñØñÉ4
À¸|6ĞâÉÒc(Z*fP¡Å„å9*–À:Gÿè¼H2ÃØ­Ø’01âè Á;ÔT±¤½{?IŞIÖ-ÁMvx	³@P£Fu
ó@ ŒP-¦Ÿ*ğ µÀB‹V4`  µŒºø´„Y‹®6’û!çŞ¥aÇ¢0;ŸU¬ŒdÛÀ5.à„uW(¸‹0oW?t8€øOf°ù
ÀP ğÕå>|7$ed³ğ=Á£Ïæ3Å-ó §ù<tm¶Êø<Æ…ha5 Çù|Ï(À{!Ñ?Z1d3¡rÀÍå¬}´‚ñGš7¸Nƒ´É p1k¾Ğ¹Of Eï0o˜ ëî p“Û\>ìå¼ÕNÿ[ŞqS]r>ĞwÏv€¬7Á	0b@@(À›e^u×ØÀ‡ ÅÃDßõ¡XhB(XÎ+‰Q`Ÿg~ÄyfÓnáå_ 60æg ‡¯¡"9~Ò
 Œ Z9äù`R‰°%A 6gsølèÇzŒÈÛ)ò& z<ğâ9CfGúx£	ğ@„YÎ Qş0~(v' ÊHD>R7Æœ…âÓ§”†Ú‡M¤7©P¨¤º½ci§†±)uïpê@£E1êŒa*ª{>ÚÃŸ€º&j˜’óf…³ÍYçaÒ¦9»ş`apŸ:@€hX
«eÿ\Şãeë1yÜ“äÈªÃ”ÃXù€~b;‘&İÊGj0šë Åş·*G™ë ¡B\û‡“(Ây^“ G*BÚÖ ›vò: Q¢K,¯½fè]“âÛCœlÓ àrè09ìúĞ£œ²×¿ıê€12C^@å©gšÃÊ?úA Çs~f]#kì~¼L/Á6L–ÀµjP³‰¹öVŞÈkjµ¡Lt#ù²m0cÅºÂ õBHsôÓö±›B‘©`4FK÷q3úz,^9m›0öB"&¶X×Š´cÔİgåÂÛ±¤di4
áÄüÀd„á¥8fsğrÿ•.	¥«XR•Eäd›:ƒ!°nÈù„é^%¥8Ií=Å¤ûxä6í%ô]Ô\»ë¾…N GÂåà~ ì»x#©@›?!‰Q|BûØNèÙ&0èà@_Y÷¾»g”6Ï9	ÏÃ®…z|ò™ecòÏ„3?4Ò Òˆ¥ĞÀôŒ ¼ 8Ğ yp`¸À]Œ@É,6è[à w4áà%4¡¼`z"¼ÆƒĞ»pv"‚UNBe|Cèà»J°C 	Ì@6¼Áˆohƒ/6Á	2 ĞÏ ƒ§HÅ*ZñŠXÌ¢·ÈÅ.zñ‹`£ÇHÆ2šñŒhL£×ÈF D  !ù	  ,    Z   ÿğÉI«½8ëÍ»ÿ`(dihª®lë¾p,Ïtmßx®ï|ïÿÀ pH,È¤rÉl:ŸĞ¨tJ­Z¯’Ãèz»€Ã Ë5$ˆc-h¯è! €„ÀÁïûÿsJ 	{€‹Œ~ƒ…CŠ™‘A•˜š¢™‚’;•—£«¢	:‡¬´£u6‰´p	rÂˆ	¡­°3ÇŒœtaZÖÖ\xÅÎ‹¸1‡Ü	ÓaêëìêèZ fÆ¢	¹- ¼›ŞtbíşÿîÜ!0oe+   µ W?€!nÉ#„(V¼)]ÄÿÃeJ–Bã³hAªx'_7Œ#ğ‰»f%;t6×Õˆ$‰Ä10 `%NˆA
°à¤=š1JvÀf
\ÈzÕè®F	N}0kÑÁªÓa¡ @ƒ£ )-\$À@ eL
pm‰¶wºtSĞ©øşÓš0R…Œ<Õ@¶›©ˆ\¸EÊ”.ÕE±‹¶Šuvt‘ƒÔ@õ"š†±ù3g·ÆdÀk@ju™kÔö'“ua
¯ıŒî;{Æğ›«ÿ$Ø=WzQ€:¯»-úøƒä}.şnĞÜ†ö·¡•¾P½Ï-Òí‚ëPÀÒ@o œ‰ÿ'Çù 4ˆÿ]€ÇGX¥ıpPÎLGÁ	ˆfÀoıñ@Ÿ?”èÈS•ı±Àuş± ‹`d ¶3@…=\¨¢}€8(‰ã$¶ØÚíä§´ÇÇ‡²èÃyéõñ¡ù"ÙC¸ÈÎa5"¹ğ­SŞÿ``]°È„ÿQ@jú±ŒØŸ
¤` 4ğ €¨“?8¹N‘á8vZyÄ?øÄXÈŸ~ éÏ•@Ø†h<>à£Š¶Ã(–ş@¨dB¨:—úà( GNZ);¡ö0ê’=ğèŸ’7h¦¯:i­|:@ª<ZkXsŠ+>è©Ÿ(¦j²Clÿ‹nvÊ™y	H³ìˆIf^}¬À—U‚ZD–[˜¤uL
alP6©º>›mğN@gxØ
*@çú©'RÉŸº©Q2%o²«¬ºY«iH¾ÀÑ&†Ñ…7Ù²İ†+®¨¶ÈzëGñŠCò;)—¬,ğÀ;¬ûÖ‰­Z€3ÉŒÇëiq!Ë²¬œbºæÕ‡ÛdÈávY‚E”q· k«oíŒÂ˜,f‘wœøl28f›×$g ñ€¯#ï_i=ke&J±³VğŸ;R;@`9·;øuÂİx?Œ¢XPrõŒGw	„ï©õÖ!¸í€+Ç—Õÿ€9^87?ƒpâåg)VY1–z[›y^ø3eƒ0À½F’“ë+İ¡]õ”À #ŞPÓğ7ÅÃ­r5—Pè3¯¤M|D[ˆŒXI“‡çîÏïdÀâJr-‚H'åüóUo$Ò'ünøØ#Uşñ°¡‚–ğ³VN5p¥%UÄÇ{2°œhP0XïÀ€€ú±Æ4à‰-Ú€€`@F.á?Æy¯Zâ^-Fè¢Ä"($a#öáƒJˆP…™ Ço`<jbˆÂ@^8BĞ„†ÈàîDó?º‚(ºqÂ´¡†58Ñ‰j°…- àŠW´·ÈÅ.$zñ‹`£ÇHÆ2šñŒhL£×ÈÆ6ºñpŒ£çHÇ:ş  !ù	  ,    Z   ÿğÉI«½8ëÍ»ÿ`(dihª®lë¾p,Ïtmßx®ï|ïÿÀ pH,È¤rÉl:ŸĞ¨tJ­Z¯Áè¾à à0°n„bÁ¸·€±@ †ñó€^Àÿ€‚qbJhƒŒpwD	™™y@•	‹š¢œ“<—£ª›: ¡«³	 7¨²š		ÁÂÁj»›®3•ÇŒtxbÒÔÕÒ \i˜¼·1°Í‚…ÑÔæçèèÔgŠš¸. îµ’åéúûæZ ôAR¶" RöÆğ[È°Á€ 1 ˆ"€±F(lÈ‘ß~ÿ%Ka1\C:ª\¸… ·AO ˆSã€•«å[ù/ä ‘$Ğd/eÇ›ç
(-€óŸ€€ Å1 £VF9*U A¦>)^–€”ßÍ^AxËpl#! ¨ıc@[~pM|å83\L\eË0pŠÁí‚ç!íOÆ¸PPwŞ :x$À@V}7ÓÕ7À"LŠ4}:]j«Ó1#M L½“d¶ÁÙ#Y8‡cÏ–Gnt®%ø}PÚIu<7·; Ød‹°«ö}«G}A=ßëüÌë(®¯Rp šMü›½ıt£E…Wÿâ’ væ ±]bÍLGP¤ÀŸ9šığ: øôS=À^ÀÃ*&E¾‡İ qa?â &²ß>Dl\Yg¹ÇÂ¥ÃbBä'‚òñb‰	r ƒ˜¶O“A<7@Š£ ¢fD~h‚:-¡À„zG@ÔÈWê´)Ä“ş‘@	ˆƒ':X
±ÏLK>è‘ƒShû	ˆYøè Wé¢“â¢!"êó(›
Z© ™QjY¸pú¦¢jZŸ« NB«²6ê‡Şz`¤5J¡|ZÚÛi8¡NÂù©ÿhöe k¢3f™ ²G¥uL—q¨$«©î©Èt+¬yæx¨¥H¢)eµŞ¸“.´2ËÃ›õ%{I>j¬¤Ây«pëw6ào ";|åòà‘Uã§½Ãö°]}>¢¼!(ñ¿íK™Œq»Æğ¤C)‡‹Á–Úâ29œÜÆì[ÚĞ9·@&?Bğ@OFr½4<½éÈ(} CMŸ Y¤JOıóÂKƒÃÎ0‚bÆ˜9ïĞ‡ÂÉıôÇ€È©ÀÙÍ<£ı+bPıáı‘0¶[…]BÔ|%pµ:uË…·ÿ:‘G8Â¾q`ÅR[ÅEÁ\`1ãÂ'‘P•HV6%{}…ÓW	
dÓì³?dÙg3—€¨@–ÓÍ{}àˆ÷B™„«FdßHÎBò%d|SÇh¹×“GôÇûc‰Û•/Â–èÛ˜Àød¨Ş?}8ÿÈu2P./÷D35Ò8ƒ6Ğ>ñM°(`TÜ€ `Â¸ÄDa‹•Å  ö£…*`šW¤%ƒÄˆ!| ‹‹„p°œş¡Àf„-EàLxBB¼O}CøG;l÷àáÁ/P`ØÀ€"±ˆl Fp…k`ã‰Ä‚§HÅ*ZñŠXÌ¢·ÈÅ.zñ‹`£ÇHÆ2šñŒhL£×ÈF*F  !ù	  ,    Z   ÿğÉI«½8ëÍ»ÿ`(dihª®lë¾p,Ïtmßx®ï|ïÿÀ pH,È¤rÉl:ŸĞ¨tJ­Z¯Á0x¿Ş àp°n	bÁ8Şpc¡NÄO.ïûÿ}v In€‹ŒeC‰˜˜ @•™¡™›<—¢©’9 	Šªrµµ²©‚7–¹t‘ÂÃÀ	ª4¸‹vbcÖÖÖd\hm£	¥/°Ï‚wcØëìíØZ]	|˜». ¨‹ƒÕîÿ ³ĞóÚ‚{+ cÄ/€¿€ÆÛÓHYBzû8©‹È – 	ÿ*"4¡°Üu\ && _base.input.charCodeAt(_base.state.pos + 1) === _charcodes.charCodes.leftCurlyBrace)
    ) {
      if (_base.state.pos === _base.state.start && match(_types.TokenType.template)) {
        if (ch === _charcodes.charCodes.dollarSign) {
          _base.state.pos += 2;
          finishToken(_types.TokenType.dollarBraceL);
          return;
        } else {
          ++_base.state.pos;
          finishToken(_types.TokenType.backQuote);
          return;
        }
      }
      finishToken(_types.TokenType.template);
      return;
    }
    if (ch === _charcodes.charCodes.backslash) {
      _base.state.pos++;
    }
    _base.state.pos++;
  }
}

// Skip to the end of the current word. Note that this is the same as the snippet at the end of
// readWord, but calling skipWord from readWord seems to slightly hurt performance from some rough
// measurements.
 function skipWord() {
  while (_base.state.pos < _base.input.length) {
    const ch = _base.input.charCodeAt(_base.state.pos);
    if (_identifier.IS_IDENTIFIER_CHAR[ch]) {
      _base.state.pos++;
    } else if (ch === _charcodes.charCodes.backslash) {
      // \u
      _base.state.pos += 2;
      if (_base.input.charCodeAt(_base.state.pos) === _charcodes.charCodes.leftCurlyBrace) {
        while (
          _base.state.pos < _base.input.length &&
          _base.input.charCodeAt(_base.state.pos) !== _charcodes.charCodes.rightCurlyBrace
        ) {
          _base.state.pos++;
        }
        _base.state.pos++;
      }
    } else {
      break;
    }
  }
} exports.skipWord = skipWord;
