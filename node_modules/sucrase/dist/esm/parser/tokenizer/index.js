ialogHydratedKeepThisPcOptionV3": "ફક્ત આ કમ્પ્યુટર",
  "kfmOptoutDehydratedDialogTitle": "બૅકઅપ લેવાનું રોકીએ?",
  "freChinaTypeApprovalPrimaryHeader": "સ્વચલિત સુધારાઓ સાથે સુરક્ષિત રહો",
  "freChinaTypeApprovalSecondaryHeader": "નિયમિત અપડેટ્સ તમને તમારી OneDriveને સુરક્ષિત રાખવામાં મદદ કરે છે અને તમને કોઈપણ ડિવાઇસ પર ઉત્પાદનલક્ષી રહેવામાં મદદરૂપ થવા માટે નવી સુવિધાઓ પણ મળશે. OneDrive દ્વારા તમારા માટે અપડેટ્સને સ્વયંસંચાલિત રૂપે ડાઉનલોડ અને ઇન્સ્ટોલ કરવામાં આવશે. નેટવર્ક ચાર્જીસ લાગુ પડી શકે છે.",
  "freChinaTypeApprovalAcceptButton": "સ્વીકારો",
  "freSignInPrimaryHeader": "OneDriveમાં સાઇન ઇન કરો",
  "freSignInSecondaryHeader": "સમગ્ર ડિવાઇસેસ પર તમારી ફાઇલો પર પાછા જાઓ, જુઓ અને સંપાદિત કરો.",
  "freSignInEmailAddressPrompt": "ઈમેલ સરનામું",
  "freSignInEmailPlaceholderText": "તમારું ઈમેલ સરનામું દાખલ કરો",
  "freSignInCreateAccountButton": "ખાતું બનાવો",
  "freSignInButton": "સાઇન ઇન કરો",
  "syncProductNameShort": "OneDrive",
  "unlinkSurveyV2DontUseOneDrive": "મારા દ્વારા OneDriveનો ઉપયોગ કરવામાં આવતો નથી",
  "unlinkSurveyV2DontWantOneDrive": "મારે મારા કમ્પ્યુટર પર OneDrive જોઈતું નથી",
  "unlinkSurveyV2NotEnoughStorage": "મારી પાસે મારી બધી ફાઇલો માટે OneDrive પર પર્યાપ્ત સ્થાન નથી",
  "unlinkSurveyV2DontKnowHowToUseOneDrive": "મને ખબર નથી કે OneDriveનો ઉપયોગ કેવી રીતે કરવો",
  "unlinkSurveyV2DontWantToSync": "મારે મારા કમ્પ્યુટર પર ફાઇલોને સિંક્રનાઇઝ કરવી નથી",
  "exitDialogTitle": "OneDrive છોડીએ?",
  "exitDialogDescription": "જો તમે OneDrive બંધ કરો છો, તો તમારા OneDrive ફોલ્ડરમાંની ફાઇલો ક્લાઉડ પર સિંક્રનાઇઝ થશે નહીં અથવા તેમનો બૅક અપ લેવાશે નહીં જેથી તમે સમગ્ર ડિવાઇસેસ પર તમારા પરિવર્તનો જોશો નહીં.",
  "exitDialogQuitButton": "OneDrive છોડી દો",
  "exitDialogCancelButton": "રદ કરો",
  "exitSurveyChooseOne": "OneDrive છોડવા માટે એક કારણ પસંદ કરો",
  "exitSurveyOneDriveAlwaysRunning": "મારે OneDrive બધો સમય ચલાવવું નથી",
  "exitSurveyDontKnowWhatOneDriveIs": "મને ખબર નથી કે OneDrive શું છે",
  "exitSurveyDontUseOneDrive": "મારા દ્વારા OneDriveનો ઉપયોગ કરવામાં આવતો નથી",
  "exitSurveyTryingToFixProblem": "મારા દ્વારા OneDrive સાથેની સમસ્યાને ઠીક કરવાનો પ્રયાસ કરવામાં આવી રહ્યો છે",
  "exitSurveyPerformance": "મારા દ્વારા મારા કમ્પ્યુટરની ઝડપ વધારવાનો પ્રયાસ કરવામાં આવી રહ્યો છે",
  "exitSurveyTooManyNotifications": "મને ઘણી બધી સૂચનાઓ મળે છે",
  "exitSurveyOther": "અન્ય",
  "kfmOptoutSurveyPrivacyStatementLink": "ગોપનીયતા વિધાન",
  "kfmOptoutSurveyReasonOther": "અન્ય",
  "moveWindowInfoAreaScanningNoProgress": "તૈયાર કરી રહ્યા છીએ...",
  "reportABugChooseImageDialogErrorUnexpected": "કોઈ અનપેક્ષિત ભૂલ આવી. કૃપયા ફરીથી પ્રયાસ કરો.",
  "systraMenuSettings": "સેટિંગ્સ",
  "systrayMenuExit": "OneDrive છોડી દો",
  "systrayMenuFeedback": "પ્રતિક્રિયા મોકલો",
  "systrayMenuReportIssue": "સમસ્યાની જાણ કરો",
  "systrayMenuGetHelp": "મદદ મેળવો",
  "systrayMenuManageStorage": "સ્ટોરેજ મેનેજ કરો",
  "systrayMenuUnlockVault": "વ્યક્તિગત વૉલ્ટને અનલૉક કરો",
  "systrayMenuLockVault": "વ્યક્તિગત વૉલ્ટ લૉક કરો",
  "systrayMenuUpgrade": "અપગ્રેડ કરો",
  "systrayMenuReportABug": "MSFT આંતરિક - બગનો અહેવાલ આપો",
  "systrayMenuPauseTimerPlural": "{1} કલાક",
  "systrayMenuPauseTimerSingular": "1 કલાક",
  "systrayMenuPauseAccessible": "{1} કલાક માટે સિંક્રનાઇઝ કરવાનું થોભો",
  "systrayMenuPauseAccessibleOne": "1 કલાક માટે સિંક્રનાઇઝ કરવાનું થોભાવો",
  "systrayMenuPause": "સિંક્રનાઇઝ કરવાનું થોભો",
  "errorViewEntryHeaderSyncIssues": "સિંક્રનાઇઝેશનની સમસ્યાઓ",
  "activityFooterButtonOpenfolder": "ફોલ્ડર ખોલો",
  "activityFooterButtonViewonline": "ઑનલાઇન જુઓ",
  "activityFooterButtonRecyclebin": "રીસાઇકલ બિન",
  "activityFooterButtonGopremium": "પ્રીમિયમ પર જાઓ",
  "activityHeaderOnedriveNotConnected": "{1} કનેક્ટ કરેલ નથી",
  "activitySummarySyncingPrimarySingular": "1 ફાઇલને સિંક્રનાઇઝ કરી રહ્યા છીએ - {3} {4}માંથી {1} {2}",
  "activitySummaryPreparingUpload": "અપલોડ કરવાની તૈયારી કરી રહ્યા છીએ",
  "activitySummaryPreparingDownload": "ડાઉનલોડ કરવાની તૈયારી કરી રહ્યા છીએ",
  "activityListProgressReviewingChanges": "સિંક્રનાઇઝ કરવાની તૈયારી કરી રહ્યા છીએ",
  "activityListProgressUploading": "અપલોડ કરી રહ્યા છીએ",
  "activityListProgressDownloading": "ડાઉનલોડ કરી રહ્યા છીએ",
  "activityListProgress": "{3} {4}માંથી {1} {2}",
  "activityListCoAuthLocked": "Will finish syncing when closed",
  "activitySummaryUploading": "{4} {5}માંથી {1} ફાઇલો, {2} {3} અપલોડ કરી રહ્યા છીએ",
  "activitySummaryUploadingSingular": "{3} {4}માંથી 1 ફાઇલ, {1} {2} અપલોડ કરી રહ્યા છીએ",
  "activitySummaryDownloading": "{4} {5}માંથી {1} ફાઇલો, {2} {3} ડાઉનલોડ કરી રહ્યા છીએ",
  "activitySummaryDownloadingSingular": "{3} {4}માંથી 1 ફાઇલ, {1} {2} ડાઉનલોડ કરી રહ્યા છીએ",
  "activitySummarySyncingPrimary": "{1} ફાઇલો સિંક્રનાઇઝ કરી રહ્યા છીએ - {4} {5}માંથી {2} {3}",
  "flyoutSyncStatusUpToDate": "તમારી ફાઇલો સિક્રનાઇઝ કરવામાં આવી છે",
  "activitySummaryCrossScopeMoving": "શેર કરેલી આઇટમ્સને ખસેડી રહ્યા છીએ",
  "activitySummaryMetadataSending": "પરિવર્તનો અપલોડ કરી રહ્યા છીએ",
  "activitySummaryMetadataReceiving": "પરિવર્તનો ડાઉનલોડ કરી રહ્યા છીએ",
  "flyoutProcessingPrimary": "પરિવર્તનો પર પ્રક્રિયા કરી રહ્યા છીએ",
  "flyoutProcessingCountSingular": "પરિવર્તન પર પ્રક્રિયા કરી રહ્યા છીએ",
  "flyoutProcessingCountPrimary": "{1} પરિવર્તનો પર પ્રક્રિયા કરી રહ્યા છીએ",
  "flyoutLookingPrimary": "પરિવર્તનો શોધી રહ્યા છીએ",
  "selectiveSyncEmailString": "OneDrive {1} ({2})",
  "activityListMenuitemOpen": "ખોલો",
  "activityListMenuitemShare": "શેર કરો",
  "activityListMenuitemViewonline": "ઑનલાઇન જુઓ",
  "activityListMenuitemVersionhistory": "સંસ્કરણ ઈતિહાસ"
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     arCodes.lineSeparator:
      case charCodes.paragraphSeparator:
        ++state.pos;
        break;

      case charCodes.slash:
        switch (input.charCodeAt(state.pos + 1)) {
          case charCodes.asterisk:
            state.pos += 2;
            skipBlockComment();
            break;

          case charCodes.slash:
            skipLineComment(2);
            break;

          default:
            return;
        }
        break;

      default:
        if (IS_WHITESPACE[ch]) {
          ++state.pos;
        } else {
          return;
        }
    }
  }
}

// Called at the end of every token. Sets various fields, and skips the space after the token, so
// that the next one's `start` will point at the right position.
export function finishToken(
  type,
  contextualKeyword = ContextualKeyword.NONE,
) {
  state.end = state.pos;
  state.type = type;
  state.contextualKeyword = contextualKeyword;
}

// ### Token reading

// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
function readToken_dot() {
  const nextChar = input.charCodeAt(state.pos + 1);
  if (nextChar >= charCodes.digit0 && nextChar <= charCodes.digit9) {
    readNumber(true);
    return;
  }

  if (nextChar === charCodes.dot && input.charCodeAt(state.pos + 2) === charCodes.dot) {
    state.pos += 3;
    finishToken(tt.ellipsis);
  } else {
    ++state.pos;
    finishToken(tt.dot);
  }
}

function readToken_slash() {
  const nextChar = input.charCodeAt(state.pos + 1);
  if (nextChar === charCodes.equalsTo) {
    finishOp(tt.assign, 2);
  } else {
    finishOp(tt.slash, 1);
  }
}

function readToken_mult_modulo(code) {
  // '%*'
  let tokenType = code === charCodes.asterisk ? tt.star : tt.modulo;
  let width = 1;
  let nextChar = input.charCodeAt(state.pos + 1);

  // Exponentiation operator **
  if (code === charCodes.asterisk && nextChar === charCodes.asterisk) {
    width++;
    nextChar = input.charCodeAt(state.pos + 2);
    tokenType = tt.exponent;
  }

  // Match *= or %=, disallowing *=> which can be valid in flow.
  if (
    nextChar === charCodes.equalsTo &&
    input.charCodeAt(state.pos + 2) !== charCodes.greaterThan
  ) {
    width++;
    tokenType = tt.assign;
  }

  finishOp(tokenType, width);
}

function readToken_pipe_amp(code) {
  // '|&'
  const nextChar = input.charCodeAt(state.pos + 1);

  if (nextChar === code) {
    if (input.charCodeAt(state.pos + 2) === charCodes.equalsTo) {
      // ||= or &&=
      finishOp(tt.assign, 3);
    } else {
      // || or &&
      finishOp(code === charCodes.verticalBar ? tt.logicalOR : tt.logicalAND, 2);
    }
    return;
  }

  if (code === charCodes.verticalBar) {
    // '|>'
    if (nextChar === charCodes.greaterThan) {
      finishOp(tt.pipeline, 2);
      return;
    } else if (nextChar === charCodes.rightCurlyBrace && isFlowEnabled) {
      // '|}'
      finishOp(tt.braceBarR, 2);
      return;
    }
  }

  if (nextChar === charCodes.equalsTo) {
    finishOp(tt.assign, 2);
    return;
  }

  finishOp(code === charCodes.verticalBar ? tt.bitwiseOR : tt.bitwiseAND, 1);
}

function readToken_caret() {
  // '^'
  const nextChar = input.charCodeAt(state.pos + 1);
  if (nextChar === charCodes.equalsTo) {
    finishOp(tt.assign, 2);
  } else {
    finishOp(tt.bitwiseXOR, 1);
  }
}

function readToken_plus_min(code) {
  // '+-'
  const nextChar = input.charCodeAt(state.pos + 1);

  if (nextChar === code) {
    // Tentatively call this a prefix operator, but it might be changed to postfix later.
    finishOp(tt.preIncDec, 2);
    return;
  }

  if (nextChar === charCodes.equalsTo) {
    finishOp(tt.assign, 2);
  } else if (code === charCodes.plusSign) {
    finishOp(tt.plus, 1);
  } else {
    finishOp(tt.minus, 1);
  }
}

function readToken_lt() {
  const nextChar = input.charCodeAt(state.pos + 1);

  if (nextChar === charCodes.lessThan) {
    if (input.charCodeAt(state.pos + 2) === charCodes.equalsTo) {
      finishOp(tt.assign, 3);
      return;
    }
    // We see <<, but need to be really careful about whether to treat it as a
    // true left-shift or as two < tokens.
    if (state.isType) {
      // Within a type, << might come up in a snippet like `Array<<T>() => void>`,
      // so treat it as two < tokens. Importantly, this should only override <<
      // rather than other tokens like <= . If we treated <= as < in a type
      // context, then the snippet `a as T <= 1` would incorrectly start parsing
      // a type argument on T. We don't need to worry about `a as T << 1`
      // because TypeScript disallows that syntax.
      finishOp(tt.lessThan, 1);
    } else {
      // Outside a type, this might be a true left-shift operator, or it might
      // still be two open-type-arg tokens, such as in `f<<T>() => void>()`. We
      // look at the token while considering the `f`, so we don't yet know that
      // we're in a type context. In this case, we initially tokenize as a
      // left-shift and correct after-the-fact as necessary in
      // tsParseTypeArgumentsWithPossibleBitshift .
      finishOp(tt.bitShiftL, 2);
    }
    return;
  }

  if (nextChar === charCodes.equalsTo) {
    // <=
    finishOp(tt.relationalOrEqual, 2);
  } else {
    finishOp(tt.lessThan, 1);
  }
}

function readToken_gt() {
  if (state.isType) {
    // Avoid right-shift for things like `Array<Array<string>>` and
    // greater-than-or-equal for things like `const a: Array<number>=[];`.
    finishOp(tt.greaterThan, 1);
    return;
  }

  const nextChar = input.charCodeAt(state.pos + 1);

  if (nextChar === charCodes.greaterThan) {
    const size = input.charCodeAt(state.pos + 2) === charCodes.greaterThan ? 3 : 2;
    if (input.charCodeAt(state.pos + size) === charCodes.equalsTo) {
      finishOp(tt.assign, size + 1);
      return;
    }
    finishOp(tt.bitShiftR, size);
    return;
  }

  if (nextChar === charCodes.equalsTo) {
    // >=
    finishOp(tt.relationalOrEqual, 2);
  } else {
    finishOp(tt.greaterThan, 1);
  }
}

/**
 * Reinterpret a possible > token when transitioning from a type to a non-type
 * context.
 *
 * This comes up in two situations where >= needs to be treated as one token:
 * - After an `as` expression, like in the code `a as T >= 1`.
 * - In a type argument in an expression context, e.g. `f(a < b, c >= d)`, we
 *   need to see the token as >= so that we get an error and backtrack to
 *   normal expression parsing.
 *
 * Other situations require >= to be seen as two tokens, e.g.
 * `const x: Array<T>=[];`, so it's important to treat > as its own token in
 * typical type parsing situations.
 */
export function rescan_gt() {
  if (state.type === tt.greaterThan) {
    state.pos -= 1;
    readToken_gt();
  }
}

function readToken_eq_excl(code) {
  // '=!'
  const nextChar = input.charCodeAt(state.pos + 1);
  if (nextChar === charCodes.equalsTo) {
    finishOp(tt.equality, input.charCodeAt(state.pos + 2) === charCodes.equalsTo ? 3 : 2);
    return;
  }
  if (code === charCodes.equalsTo && nextChar === charCodes.greaterThan) {
    // '=>'
    state.pos += 2;
    finishToken(tt.arrow);
    return;
  }
  finishOp(code === charCodes.equalsTo ? tt.eq : tt.bang, 1);
}

function readToken_question() {
  // '?'
  const nextChar = input.charCodeAt(state.pos + 1);
  const nextChar2 = input.charCodeAt(state.pos + 2);
  if (
    nextChar === charCodes.questionMark &&
    // In Flow (but not TypeScript), ??string is a valid type that should be
    // tokenized as two individual ? tokens.
    !(isFlowEnabled && state.isType)
  ) {
    if (nextChar2 === charCodes.equalsTo) {
      // '??='
      finishOp(tt.assign, 3);
    } else {
      // '??'
      finishOp(tt.nullishCoalescing, 2);
    }
  } else if (
    nextChar === charCodes.dot &&
    !(nextChar2 >= charCodes.digit0 && nextChar2 <= charCodes.digit9)
  ) {
    // '.' not followed by a number
    state.pos += 2;
    finishToken(tt.questionDot);
  } else {
    ++state.pos;
    finishToken(tt.question);
  }
}

export function getTokenFromCode(code) {
  switch (code) {
    case charCodes.numberSign:
      ++state.pos;
      finishToken(tt.hash);
      return;

    // The interpretation of a dot depends on whether it is followed
    // by a digit or another two dots.

    case charCodes.dot:
      readToken_dot();
      return;

    // Punctuation tokens.
    case charCodes.leftParenthesis:
      ++state.pos;
      finishToken(tt.parenL);
      return;
    case charCodes.rightParenthesis:
      ++state.pos;
      finishToken(tt.parenR);
      return;
    case charCodes.semicolon:
      ++state.pos;
      finishToken(tt.semi);
      return;
    case charCodes.comma:
      ++state.pos;
      finishToken(tt.comma);
      return;
    case charCodes.leftSquareBracket:
      ++state.pos;
      finishToken(tt.bracketL);
      return;
    case charCodes.rightSquareBracket:
      ++state.pos;
      finishToken(tt.bracketR);
      return;

    case charCodes.leftCurlyBrace:
      if (isFlowEnabled && input.charCodeAt(state.pos + 1) === charCodes.verticalBar) {
        finishOp(tt.braceBarL, 2);
      } else {
        ++state.pos;
        finishToken(tt.braceL);
      }
      return;

    case charCodes.rightCurlyBrace:
      ++state.pos;
      finishToken(tt.braceR);
      return;

    case charCodes.colon:
      if (input.charCodeAt(state.pos + 1) === charCodes.colon) {
        finishOp(tt.doubleColon, 2);
      } else {
        ++state.pos;
        finishToken(tt.colon);
      }
      return;

    case charCodes.questionMark:
      readToken_question();
      return;
    case charCodes.atSign:
      ++state.pos;
      finishToken(tt.at);
      return;

    case charCodes.graveAccent:
      ++state.pos;
      finishToken(tt.backQuote);
      return;

    case charCodes.digit0: {
      const nextChar = input.charCodeAt(state.pos + 1);
      // '0x', '0X', '0o', '0O', '0b', '0B'
      if (
        nextChar === charCodes.lowercaseX ||
        nextChar === charCodes.uppercaseX ||
        nextChar === charCodes.lowercaseO ||
        nextChar === charCodes.uppercaseO ||
        nextChar === charCodes.lowercaseB ||
        nextChar === charCodes.uppercaseB
      ) {
        readRadixNumber();
        return;
      }
    }
    // Anything else beginning with a digit is an integer, octal
    // number, or float.
    case charCodes.digit1:
    case charCodes.digit2:
    case charCodes.digit3:
    case charCodes.digit4:
    case charCodes.digit5:
    case charCodes.digit6:
    case charCodes.digit7:
    case charCodes.digit8:
    case charCodes.digit9:
      readNumber(false);
      return;

    // Quotes produce strings.
    case charCodes.quotationMark:
    case charCodes.apostrophe:
      readString(code);
      return;

    // Operators are parsed inline in tiny state machines. '=' (charCodes.equalsTo) is
    // often referred to. `finishOp` simply skips the amount of
    // characters it is given as second argument, and returns a token
    // of the type given by its first argument.

    case charCodes.slash:
      readToken_slash();
      return;

    case charCodes.percentSign:
    case charCodes.asterisk:
      readToken_mult_modulo(code);
      return;

    case charCodes.verticalBar:
    case charCodes.ampersand:
      readToken_pipe_amp(code);
      return;

    case charCodes.caret:
      readToken_caret();
      return;

    case charCodes.plusSign:
    case charCodes.dash:
      readToken_plus_min(code);
      return;

    case charCodes.lessThan:
      readToken_lt();
      return;

    case charCodes.greaterThan:
      readToken_gt();
      return;

    case charCodes.equalsTo:
    case charCodes.exclamationMark:
      readToken_eq_excl(code);
      return;

    case charCodes.tilde:
      finishOp(tt.tilde, 1);
      return;

    default:
      break;
  }

  unexpected(`Unexpected character '${String.fromCharCode(code)}'`, state.pos);
}

function finishOp(type, size) {
  state.pos += size;
  finishToken(type);
}

function readRegexp() {
  const start = state.pos;
  let escaped = false;
  let inClass = false;
  for (;;) {
    if (state.pos >= input.length) {
      unexpected("Unterminated regular expression", start);
      return;
    }
    const code = input.charCodeAt(state.pos);
    if (escaped) {
      escaped = false;
    } else {
      if (code === charCodes.leftSquareBracket) {
        inClass = true;
      } else if (code === charCodes.rightSquareBracket && inClass) {
        inClass = false;
      } else if (code === charCodes.slash && !inClass) {
        break;
      }
      escaped = code === charCodes.backslash;
    }
    ++state.pos;
  }
  ++state.pos;
  // Need to use `skipWord` because '\uXXXX' sequences are allowed here (don't ask).
  skipWord();

  finishToken(tt.regexp);
}

/**
 * Read a decimal integer. Note that this can't be unified with the similar code
 * in readRadixNumber (which also handles hex digits) because "e" needs to be
 * the end of the integer so that we can properly handle scientific notation.
 */
function readInt() {
  while (true) {
    const code = input.charCodeAt(state.pos);
    if ((code >= charCodes.digit0 && code <= charCodes.digit9) || code === charCodes.underscore) {
      state.pos++;
    } else {
      break;
    }
  }
}

function readRadixNumber() {
  state.pos += 2; // 0x

  // Walk to the end of the number, allowing hex digits.
  while (true) {
    const code = input.charCodeAt(state.pos);
    if (
      (code >= charCodes.digit0 && code <= charCodes.digit9) ||
      (code >= charCodes.lowercaseA && code <= charCodes.lowercaseF) ||
      (code >= charCodes.uppercaseA && code <= charCodes.uppercaseF) ||
      code === charCodes.underscore
    ) {
      state.pos++;
    } else {
      break;
    }
  }

  const nextChar = input.charCodeAt(state.pos);
  if (nextChar === charCodes.lowercaseN) {
    ++state.pos;
    finishToken(tt.bigint);
  } else {
    finishToken(tt.num);
  }
}

// Read an integer, octal integer, or floating-point number.
function readNumber(startsWithDot) {
  let isBigInt = false;
  let isDecimal = false;

  if (!startsWithDot) {
    readInt();
  }

  let nextChar = input.charCodeAt(state.pos);
  if (nextChar === charCodes.dot) {
    ++state.pos;
    readInt();
    nextChar = input.charCodeAt(state.pos);
  }

  if (nextChar === charCodes.uppercaseE || nextChar === charCodes.lowercaseE) {
    nextChar = input.charCodeAt(++state.pos);
    if (nextChar === charCodes.plusSign || nextChar === charCodes.dash) {
      ++state.pos;
    }
    readInt();
    nextChar = input.charCodeAt(state.pos);
  }

  if (nextChar === charCodes.lowercaseN) {
    ++state.pos;
    isBigInt = true;
  } else if (nextChar === charCodes.lowercaseM) {
    ++state.pos;
    isDecimal = true;
  }

  if (isBigInt) {
    finishToken(tt.bigint);
    return;
  }

  if (isDecimal) {
    finishToken(tt.decimal);
    return;
  }

  finishToken(tt.num);
}

function readString(quote) {
  state.pos++;
  for (;;) {
    if (state.pos >= input.length) {
      unexpected("Unterminated string constant");
      return;
    }
    const ch = input.charCodeAt(state.pos);
    if (ch === charCodes.backslash) {
      state.pos++;
    } else if (ch === quote) {
      break;
    }
    state.pos++;
  }
  state.pos++;
  finishToken(tt.string);
}

// Reads template string tokens.
function readTmplToken() {
  for (;;) {
    if (state.pos >= input.length) {
      unexpected("Unterminated template");
      return;
    }
    const ch = input.charCodeAt(state.pos);
    if (
      ch === charCodes.graveAccent ||
      (ch === charCodes.dollarSign && input.charCodeAt(state.pos + 1) === charCodes.leftCurlyBrace)
    ) {
      if (state.pos === state.start && match(tt.template)) {
        if (ch === charCodes.dollarSign) {
          state.pos += 2;
          finishToken(tt.dollarBraceL);
          return;
        } else {
          ++state.pos;
          finishToken(tt.backQuote);
          return;
        }
      }
      finishToken(tt.template);
      return;
    }
    if (ch === charCodes.backslash) {
      state.pos++;
    }
    state.pos++;
  }
}

// Skip to the end of the current word. Note that this is the same as the snippet at the end of
// readWord, but calling skipWord from readWord seems to slightly hurt performance from some rough
// measurements.
export function skipWord() {
  while (state.pos < input.length) {
    const ch = input.charCodeAt(state.pos);
    if (IS_IDENTIFIER_CHAR[ch]) {
      state.pos++;
    } else if (ch === charCodes.backslash) {
      // \u
      state.pos += 2;
      if (input.charCodeAt(state.pos) === charCodes.leftCurlyBrace) {
        while (
          state.pos < input.length &&
          input.charCodeAt(state.pos) !== charCodes.rightCurlyBrace
        ) {
          state.pos++;
        }
        state.pos++;
      }
    } else {
      break;
    }
  }
}
