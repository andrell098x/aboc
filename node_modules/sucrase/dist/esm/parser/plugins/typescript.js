import {
  eat,
  finishToken,
  IdentifierRole,
  lookaheadType,
  lookaheadTypeAndKeyword,
  match,
  next,
  nextTemplateToken,
  popTypeContext,
  pushTypeContext,
  rescan_gt,
} from "../tokenizer/index";
import {ContextualKeyword} from "../tokenizer/keywords";
import {TokenType, TokenType as tt} from "../tokenizer/types";
import {isJSXEnabled, state} from "../traverser/base";
import {
  atPossibleAsync,
  baseParseMaybeAssign,
  baseParseSubscript,
  parseCallExpressionArguments,
  parseExprAtom,
  parseExpression,
  parseFunctionBody,
  parseIdentifier,
  parseLiteral,
  parseMaybeAssign,
  parseMaybeUnary,
  parsePropertyName,
  parseTemplate,

} from "../traverser/expression";
import {parseBindingIdentifier, parseBindingList, parseImportedIdentifier} from "../traverser/lval";
import {
  baseParseMaybeDecoratorArguments,
  parseBlockBody,
  parseClass,
  parseFunction,
  parseFunctionParams,
  parseStatement,
  parseVarStatement,
} from "../traverser/statement";
import {
  canInsertSemicolon,
  eatContextual,
  expect,
  expectContextual,
  hasPrecedingLineBreak,
  isContextual,
  isLineTerminator,
  isLookaheadContextual,
  semicolon,
  unexpected,
} from "../traverser/util";
import {nextJSXTagToken} from "./jsx";

function tsIsIdentifier() {
  // TODO: actually a bit more complex in TypeScript, but shouldn't matter.
  // See https://github.com/Microsoft/TypeScript/issues/15008
  return match(tt.name);
}

function isLiteralPropertyName() {
  return (
    match(tt.name) ||
    Boolean(state.type & TokenType.IS_KEYWORD) ||
    match(tt.string) ||
    match(tt.num) ||
    match(tt.bigint) ||
    match(tt.decimal)
  );
}

function tsNextTokenCanFollowModifier() {
  // Note: TypeScript's implementation is much more complicated because
  // more things are considered modifiers there.
  // This implementation only handles modifiers not handled by babylon itself. And "static".
  // TODO: Would be nice to avoid lookahead. Want a hasLineBreakUpNext() method...
  const snapshot = state.snapshot();

  next();
  const canFollowModifier =
    (match(tt.bracketL) ||
      match(tt.braceL) ||
      match(tt.star) ||
      match(tt.ellipsis) ||
      match(tt.hash) ||
      isLiteralPropertyName()) &&
    !hasPrecedingLineBreak();

  if (canFollowModifier) {
    return true;
  } else {
    state.restoreFromSnapshot(snapshot);
    return false;
  }
}

export function tsParseModifiers(allowedModifiers) {
  while (true) {
    const modifier = tsParseModifier(allowedModifiers);
    if (modifier === null) {
      break;
    }
  }
}

/** Parses a modifier matching one the given modifier names. */
export function tsParseModifier(
  allowedModifiers,
) {
  if (!match(tt.name)) {
    return null;
  }

  const modifier = state.contextualKeyword;
  if (allowedModifiers.indexOf(modifier) !== -1 && tsNextTokenCanFollowModifier()) {
    switch (modifier) {
      case ContextualKeyword._readonly:
        state.tokens[state.tokens.length - 1].type = tt._readonly;
        break;
      case ContextualKeyword._abstract:
        state.tokens[state.tokens.length - 1].type = tt._abstract;
        break;
      case ContextualKeyword._static:
        state.tokens[state.tokens.length - 1].type = tt._static;
        break;
      case ContextualKeyword._public:
        state.tokens[state.tokens.length - 1].type = tt._public;
        break;
      case ContextualKeyword._private:
        state.tokens[state.tokens.length - 1].type = tt._private;
        break;
      case ContextualKeyword._protected:
        state.tokens[state.tokens.length - 1].type = tt._protected;
        break;
      case ContextualKeyword._override:
        state.tokens[state.tokens.length - 1].type = tt._override;
        break;
      case ContextualKeyword._declare:
        state.tokens[state.tokens.length - 1].type = tt._declare;
        break;
      default:
        break;
    }
    return modifier;
  }
  return null;
}

function tsParseEntityName() {
  parseIdentifier();
  while (eat(tt.dot)) {
    parseIdentifier();
  }
}

function tsParseTypeReference() {
  tsParseEntityName();
 dFilesUnpinOptionDescriptionV2": "‡¥®‡¥ø‡¥ô‡µç‡¥ô‡µæ ‡¥§‡µÅ‡¥±‡¥®‡µç‡¥®‡¥ø‡¥ü‡µç‡¥ü‡¥ø‡¥≤‡µç‡¥≤‡¥æ‡¥§‡µç‡¥§ OneDrive ‡¥´‡¥Ø‡¥≤‡µÅ‡¥ï‡µæ ‡¥à ‡¥â‡¥™‡¥ï‡¥∞‡¥£‡¥§‡µç‡¥§‡¥ø‡µΩ ‡¥§‡µÅ‡¥±‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡¥§‡µç ‡¥µ‡¥∞‡µÜ ‡¥ì‡µ∫‡¥≤‡µà‡¥®‡¥ø‡µΩ ‡¥Æ‡¥æ‡¥§‡µç‡¥∞‡¥Æ‡µá ‡¥≤‡¥≠‡µç‡¥Ø‡¥Æ‡¥æ‡¥ï‡µÇ. ‡¥§‡µÅ‡¥ü‡µº‡¥®‡µç‡¥®‡µç ‡¥´‡¥Ø‡¥≤‡µÅ‡¥ï‡µæ ‡¥°‡µó‡µ∫‡¥≤‡µã‡¥°‡µç ‡¥ö‡µÜ‡¥Ø‡µç‡¥§‡µç ‡¥ì‡¥´‡µç‚Äå‡¥≤‡µà‡¥®‡¥ø‡µΩ ‡¥≤‡¥≠‡µç‡¥Ø‡¥Æ‡¥æ‡¥ï‡µÅ‡¥Ç.",
  "cloudFilesUnpinButtonRnV2": "‡¥´‡¥Ø‡¥≤‡µÅ‡¥ï‡µæ ‡¥§‡µÅ‡¥±‡¥ï‡µç‡¥ï‡µÅ‡¥Æ‡µç‡¥™‡µã‡µæ ‡¥°‡µó‡µ∫‡¥≤‡µã‡¥°‡µç ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥ï",
  "cloudFilesPinButtonV2": "‡¥é‡¥≤‡µç‡¥≤‡¥æ ‡¥´‡¥Ø‡¥≤‡µÅ‡¥ï‡¥≥‡µÅ‡¥Ç ‡¥á‡¥™‡µç‡¥™‡µã‡µæ ‡¥°‡µó‡µ∫‡¥≤‡µã‡¥°‡µç ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥ï",
  "kfmWindowScanningText": "‡¥∏‡µç‡¥ï‡¥æ‡¥®‡µç‚Äç ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥®‡µç‡¥®‡µÅ‚Ä¶",
  "kfmWindowFolderSizeText": "‡¥¨‡¥æ‡¥ï‡µç‡¥ï‡¥™‡µç‡¥™‡¥ø‡¥®‡µç ‡¥∂‡µá‡¥∑‡¥Ç {1} / {2} ‡¥â‡¥™‡¥Ø‡µã‡¥ó‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥Ç",
  "kfmWindowSaveChangeText": "‡¥Æ‡¥æ‡¥±‡µç‡¥±‡¥ô‡µç‡¥ô‡µæ ‡¥∏‡¥Ç‡¥∞‡¥ï‡µç‡¥∑‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥ï",
  "kfmWindowSkipBackupText": "‡¥û‡¥æ‡µª ‡¥™‡¥ø‡¥®‡µç‡¥®‡µÄ‡¥ü‡µç ‡¥Ö‡¥§‡µç ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥Ç",
  "kfmWindowFolderStatusSyncing": "‡¥∏‡¥Æ‡¥®‡µç‡¥µ‡¥Ø‡¥ø‡¥™‡µç‡¥™‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡µÅ...",
  "kfmWindowLearnMoreAboutMessage": "‡¥à ‡¥∏‡¥®‡µç‡¥¶‡µá‡¥∂‡¥§‡µç‡¥§‡µÜ ‡¥ï‡µÅ‡¥±‡¥ø‡¥ö‡µç‡¥ö‡µç ‡¥ï‡µÇ‡¥ü‡µÅ‡¥§‡¥≤‡¥±‡¥ø‡¥Ø‡µÅ‡¥ï",
  "kfmWindowLearnMoreAboutIssue": "‡¥à ‡¥™‡µç‡¥∞‡¥∂‡µç‡¥®‡¥§‡µç‡¥§‡µÜ ‡¥ï‡µÅ‡¥±‡¥ø‡¥ö‡µç‡¥ö‡µç ‡¥ï‡µÇ‡¥ü‡µÅ‡¥§‡¥≤‡¥±‡¥ø‡¥Ø‡µÅ‡¥ï",
  "kfmWindowWithinQuotaLimitText": "‡¥ï‡µÇ‡¥ü‡µÅ‡¥§‡µΩ ‡¥∏‡¥Ç‡¥≠‡¥∞‡¥£‡¥Ç ‡¥â‡¥™‡¥Ø‡µã‡¥ó‡¥ø‡¥ö‡µç‡¥ö‡µç ‡¥ï‡µÇ‡¥ü‡µÅ‡¥§‡µΩ ‡¥´‡¥Ø‡¥≤‡µÅ‡¥ï‡µæ ‡¥∏‡¥Æ‡¥®‡µç‡¥µ‡¥Ø‡¥ø‡¥™‡µç‡¥™‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥ï",
  "kfmWindowExceededQuotaLimitText": "‡¥®‡¥ø‡¥ô‡µç‡¥ô‡¥≥‡µÅ‡¥ü‡µÜ ‡¥´‡µã‡µæ‡¥°‡¥±‡µÅ‡¥ï‡µæ ‡¥∏‡¥Æ‡¥®‡µç‡¥µ‡¥Ø‡¥ø‡¥™‡µç‡¥™‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡¥§‡¥ø‡¥®‡µÅ‡¥Ç ‡¥™‡¥∞‡¥ø‡¥∞‡¥ï‡µç‡¥∑‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡¥§‡¥ø‡¥®‡µÅ‡¥Ç ‡¥ï‡µÇ‡¥ü‡µÅ‡¥§‡µΩ ‡¥∏‡¥Ç‡¥≠‡¥∞‡¥£‡¥Ç ‡¥®‡µá‡¥ü‡µÅ‡¥ï",
  "kfmWindowFolderSyncErrorText": "‡¥∏‡¥Æ‡¥®‡µç‡¥µ‡¥Ø‡¥ø‡¥™‡µç‡¥™‡¥ø‡¥ï‡µç‡¥ï‡¥æ‡µª ‡¥ï‡¥¥‡¥ø‡¥Ø‡¥ø‡¥≤‡µç‡¥≤",
  "kfmWindowSyncErrorHeaderText": "‡¥§‡µÜ‡¥±‡µç‡¥±‡µç",
  "upsellCallToActionPrimaryUpgrade": "‡¥Ö‡¥™‡µç‡¥ó‡µç‡¥∞‡µá‡¥°‡µÅ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥ï",
  "kfmWindowFolderStatusSyncedV2": "‡¥¨‡¥æ‡¥ï‡µç‡¥ï‡¥™‡µç‡¥™‡µÅ‡¥ö‡µÜ‡¥Ø‡µç‡¥§‡µÅ",
  "kfmWindowFolderStatusSelectedV2": "‡¥¨‡¥æ‡¥ï‡µç‡¥ï‡¥™‡µç‡¥™‡µç ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡¥æ‡µª ‡¥§‡¥Ø‡µç‡¥Ø‡¥æ‡¥±‡¥æ‡¥£‡µç",
  "kfmWindowFolderStatusUnselectedV2": "‡¥¨‡¥æ‡¥ï‡µç‡¥ï‡¥™‡µç‡¥™‡µç ‡¥ö‡µÜ‡¥Ø‡µç‚Äå‡¥§‡¥ø‡¥ü‡µç‡¥ü‡¥ø‡¥≤‡µç‡¥≤",
  "kfmWindowCloseText": "‡¥Ö‡¥ü‡¥Ø‡µç‡¥ï‡µç‡¥ï‡µÅ‡¥ï",
  "kfmWindowStartSyncTextV2": "‡¥¨‡¥æ‡¥ï‡µç‡¥ï‡¥™‡µç‡¥™‡µç ‡¥Ü‡¥∞‡¥Ç‡¥≠‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥ï",
  "kfmWindowLossAversionDialogBody": "‡¥®‡¥ø‡¥ô‡µç‡¥ô‡µæ ‡¥í‡¥∞‡µÅ ‡¥´‡µã‡µæ‡¥°‡µº ‡¥¨‡¥æ‡¥ï‡µç‡¥ï‡¥™‡µç‡¥™‡µç ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥®‡µç‡¥®‡¥§‡µç ‡¥®‡¥ø‡µº‡¥§‡µç‡¥§‡µÅ‡¥Æ‡µç‡¥™‡µã‡µæ, ‡¥™‡µÅ‡¥§‡¥ø‡¥Ø ‡¥´‡¥Ø‡¥≤‡µÅ‡¥ï‡µæ ‡¥®‡¥ø‡¥ô‡µç‡¥ô‡¥≥‡µÅ‡¥ü‡µÜ ‡¥â‡¥™‡¥ï‡¥∞‡¥£‡¥§‡µç‡¥§‡¥ø‡¥≤‡µá‡¥ï‡µç‡¥ï‡µç ‡¥Æ‡¥æ‡¥§‡µç‡¥∞‡¥Ç ‡¥∏‡¥Ç‡¥∞‡¥ï‡µç‡¥∑‡¥ø‡¥ï‡µç‡¥ï‡¥™‡µç‡¥™‡µÜ‡¥ü‡µÅ‡¥®‡µç‡¥®‡µÅ, ‡¥Æ‡¥±‡µç‡¥±‡µç ‡¥â‡¥™‡¥ï‡¥∞‡¥£‡¥ô‡µç‡¥ô‡¥≥‡¥ø‡µΩ ‡¥≤‡¥≠‡µç‡¥Ø‡¥Æ‡¥æ‡¥ï‡µÅ‡¥ï‡¥Ø‡µã OneDrive-‡µΩ ‡¥™‡¥∞‡¥ø‡¥∞‡¥ï‡µç‡¥∑‡¥ø‡¥ï‡µç‡¥ï‡¥™‡µç‡¥™‡µÜ‡¥ü‡µÅ‡¥ï‡¥Ø‡µã ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥®‡µç‡¥®‡¥ø‡¥≤‡µç‡¥≤.",
  "kfmWindowLossAversionDialogPrimaryButtonText": "‡¥¨‡¥æ‡¥ï‡µç‡¥ï‡¥™‡µç‡¥™‡µç ‡¥§‡µÅ‡¥ü‡¥∞‡µÅ‡¥ï",
  "kfmWindowLossAversionDialogSecondaryButtonText": "‡¥¨‡¥æ‡¥ï‡µç‡¥ï‡¥™‡µç‡¥™‡µç ‡¥®‡¥ø‡µº‡¥§‡µç‡¥§‡µÅ‡¥ï",
  "kfmOptoutSurveyTitle": "‡¥®‡¥ø‡¥ô‡µç‡¥ô‡¥≥‡µÅ‡¥ü‡µÜ ‡¥Ö‡¥®‡µÅ‡¥≠‡¥µ‡¥Ç ‡¥Æ‡µÜ‡¥ö‡µç‡¥ö‡¥™‡µç‡¥™‡µÜ‡¥ü‡µÅ‡¥§‡µç‡¥§‡¥æ‡µª ‡¥∏‡¥π‡¥æ‡¥Ø‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡¥§‡¥ø‡¥®‡µç ‡¥û‡¥ô‡µç‡¥ô‡µæ‡¥ï‡µç‡¥ï‡µç ‡¥´‡µÄ‡¥°‡µç‡¥¨‡¥æ‡¥ï‡µç‡¥ï‡µç ‡¥®‡µΩ‡¥ï‡µÅ‡¥ï",
  "kfmOptoutSurveyPrompt": "‡¥é‡¥®‡µç‡¥§‡µÅ‡¥ï‡µä‡¥£‡µç‡¥ü‡¥æ‡¥£‡µç ‡¥®‡¥ø‡¥ô‡µç‡¥ô‡µæ ‡¥à ‡¥´‡µã‡µæ‡¥°‡¥±‡µÅ‡¥ï‡µæ ‡¥¨‡¥æ‡¥ï‡µç‡¥ï‡¥™‡µç‡¥™‡µç ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥®‡µç‡¥®‡¥§‡µç ‡¥®‡¥ø‡µº‡¥§‡µç‡¥§‡¥ø‡¥Ø‡¥§‡µÜ‡¥®‡µç‡¥®‡µç ‡¥û‡¥ô‡µç‡¥ô‡¥≥‡µã‡¥ü‡µç ‡¥™‡¥±‡¥Ø‡µÇ:",
  "kfmOptoutSurveyReasonUnwantedOnOtherDevices": "‡¥Æ‡¥±‡µç‡¥±‡µç ‡¥â‡¥™‡¥ï‡¥∞‡¥£‡¥ô‡µç‡¥ô‡¥≥‡¥ø‡µΩ ‡¥é‡¥®‡µç‡¥±‡µÜ ‡¥´‡ return;
  }
  if (
    (isContextual(ContextualKeyword._get) || isContextual(ContextualKeyword._set)) &&
    tsNextTokenCanFollowModifier()
  ) {
    // This is a getter/setter on a type. The tsNextTokenCanFollowModifier
    // function already called next() for us, so continue parsing the name.
  }
  parsePropertyName(-1 /* Types don't need context IDs. */);
  tsParsePropertyOrMethodSignature(readonly);
}

function tsParseTypeLiteral() {
  tsParseObjectTypeMembers();
}

function tsParseObjectTypeMembers() {
  expect(tt.braceL);
  while (!eat(tt.braceR) && !state.error) {
    tsParseTypeMember();
  }
}

function tsLookaheadIsStartOfMappedType() {
  const snapshot = state.snapshot();
  const isStartOfMappedType = tsIsStartOfMappedType();
  state.restoreFromSnapshot(snapshot);
  return isStartOfMappedType;
}

function tsIsStartOfMappedType() {
  next();
  if (eat(tt.plus) || eat(tt.minus)) {
    return isContextual(ContextualKeyword._readonly);
  }
  if (isContextual(ContextualKeyword._readonly)) {
    next();
  }
  if (!match(tt.bracketL)) {
    return false;
  }
  next();
  if (!tsIsIdentifier()) {
    return false;
  }
  next();
  return match(tt._in);
}

function tsParseMappedTypeParameter() {
  parseIdentifier();
  expect(tt._in);
  tsParseType();
}

function tsParseMappedType() {
  expect(tt.braceL);
  if (match(tt.plus) || match(tt.minus)) {
    next();
    expectContextual(ContextualKeyword._readonly);
  } else {
    eatContextual(ContextualKeyword._readonly);
  }
  expect(tt.bracketL);
  tsParseMappedTypeParameter();
  if (eatContextual(ContextualKeyword._as)) {
    tsParseType();
  }
  expect(tt.bracketR);
  if (match(tt.plus) || match(tt.minus)) {
    next();
    expect(tt.question);
  } else {
    eat(tt.question);
  }
  tsTryParseType();
  semicolon();
  expect(tt.braceR);
}

function tsParseTupleType() {
  expect(tt.bracketL);
  while (!eat(tt.bracketR) && !state.error) {
    // Do not validate presence of either none or only labeled elements
    tsParseTupleElementType();
    eat(tt.comma);
  }
}

function tsParseTupleElementType() {
  // parses `...TsType[]`
  if (eat(tt.ellipsis)) {
    tsParseType();
  } else {
    // parses `TsType?`
    tsParseType();
    eat(tt.question);
  }

  // The type we parsed above was actually a label
  if (eat(tt.colon)) {
    // Labeled tuple types must affix the label with `...` or `?`, so no need to handle those here
    tsParseType();
  }
}

function tsParseParenthesizedType() {
  expect(tt.parenL);
  tsParseType();
  expect(tt.parenR);
}

function tsParseTemplateLiteralType() {
  // Finish `, read quasi
  nextTemplateToken();
  // Finish quasi, read ${
  nextTemplateToken();
  while (!match(tt.backQuote) && !state.error) {
    expect(tt.dollarBraceL);
    tsParseType();
    // Finish }, read quasi
    nextTemplateToken();
    // Finish quasi, read either ${ or `
    nextTemplateToken();
  }
  next();
}

var FunctionType; (function (FunctionType) {
  const TSFunctionType = 0; FunctionType[FunctionType["TSFunctionType"] = TSFunctionType] = "TSFunctionType";
  const TSConstructorType = TSFunctionType + 1; FunctionType[FunctionType["TSConstructorType"] = TSConstructorType] = "TSConstructorType";
  const TSAbstractConstructorType = TSConstructorType + 1; FunctionType[FunctionType["TSAbstractConstructorType"] = TSAbstractConstructorType] = "TSAbstractConstructorType";
})(FunctionType || (FunctionType = {}));

function tsParseFunctionOrConstructorType(type) {
  if (type === FunctionType.TSAbstractConstructorType) {
    expectContextual(ContextualKeyword._abstract);
  }
  if (type === FunctionType.TSConstructorType || type === FunctionType.TSAbstractConstructorType) {
    expect(tt._new);
  }
  const oldInDisallowConditionalTypesContext = state.inDisallowConditionalTypesContext;
  state.inDisallowConditionalTypesContext = false;
  tsFillSignature(tt.arrow);
  state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
}

function tsParseNonArrayType() {
  switch (state.type) {
    case tt.name:
      tsParseTypeReference();
      return;
    case tt._void:
    case tt._null:
      next();
      return;
    case tt.string:
    case tt.num:
    case tt.bigint:
    case tt.decimal:
    case tt._true:
    case tt._false:
      parseLiteral();
      return;
    case tt.minus:
      next();
      parseLiteral();
      return;
    case tt._this: {
      tsParseThisTypeNode();
      if (isContextual(ContextualKeyword._is) && !hasPrecedingLineBreak()) {
        tsParseThisTypePredicate();
      }
      return;
    }
    case tt._typeof:
      tsParseTypeQuery();
      return;
    case tt._import:
      tsParseImportType();
      return;
    case tt.braceL:
      if (tsLookaheadIsStartOfMappedType()) {
        tsParseMappedType();
      } else {
        tsParseTypeLiteral();
      }
      return;
    case tt.bracketL:
      tsParseTupleType();
      return;
    case tt.parenL:
      tsParseParenthesizedType();
      return;
    case tt.backQuote:
      tsParseTemplateLiteralType();
      return;
    default:
      if (state.type & TokenType.IS_KEYWORD) {
        next();
        state.tokens[state.tokens.length - 1].type = tt.name;
        return;
      }
      break;
  }

  unexpected();
}

function tsParseArrayTypeOrHigher() {
  tsParseNonArrayType();
  while (!hasPrecedingLineBreak() && eat(tt.bracketL)) {
    if (!eat(tt.bracketR)) {
      // If we hit ] immediately, this is an array type, otherwise it's an indexed access type.
      tsParseType();
      expect(tt.bracketR);
    }
  }
}

function tsParseInferType() {
  expectContextual(ContextualKeyword._infer);
  parseIdentifier();
  if (match(tt._extends)) {
    // Infer type constraints introduce an ambiguity about whether the "extends"
    // is a constraint for this infer type or is another conditional type.
    const snapshot = state.snapshot();
    expect(tt._extends);
    const oldInDisallowConditionalTypesContext = state.inDisallowConditionalTypesContext;
    state.inDisallowConditionalTypesContext = true;
    tsParseType();
    state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
    if (state.error || (!state.inDisallowConditionalTypesContext && match(tt.question))) {
      state.restoreFromSnapshot(snapshot);
    }
  }
}

function tsParseTypeOperatorOrHigher() {
  if (
    isContextual(ContextualKeyword._keyof) ||
    isContextual(ContextualKeyword._unique) ||
    isContextual(ContextualKeyword._readonly)
  ) {
    next();
    tsParseTypeOperatorOrHigher();
  } else if (isContextual(ContextualKeyword._infer)) {
    tsParseInferType();
  } else {
    const oldInDisallowConditionalTypesContext = state.inDisallowConditionalTypesContext;
    state.inDisallowConditionalTypesContext = false;
    tsParseArrayTypeOrHigher();
    state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
  }
}

function tsParseIntersectionTypeOrHigher() {
  eat(tt.bitwiseAND);
  tsParseTypeOperatorOrHigher();
  if (match(tt.bitwiseAND)) {
    while (eat(tt.bitwiseAND)) {
      tsParseTypeOperatorOrHigher();
    }
  }
}

function tsParseUnionTypeOrHigher() {
  eat(tt.bitwiseOR);
  tsParseIntersectionTypeOrHigher();
  if (match(tt.bitwiseOR)) {
    while (eat(tt.bitwiseOR)) {
      tsParseIntersectionTypeOrHigher();
    }
  }
}

function tsIsStartOfFunctionType() {
  if (match(tt.lessThan)) {
    return true;
  }
  return match(tt.parenL) && tsLookaheadIsUnambiguouslyStartOfFunctionType();
}

function tsSkipParameterStart() {
  if (match(tt.name) || match(tt._this)) {
    next();
    return true;
  }
  // If this is a possible array/object destructure, walk to the matching bracket/brace.
  // The next token after will tell us definitively whether this is a function param.
  if (match(tt.braceL) || match(tt.bracketL)) {
    let depth = 1;
    next();
    while (depth > 0 && !state.error) {
      if (match(tt.braceL) || match(tt.bracketL)) {
        depth++;
      } else if (match(tt.braceR) || match(tt.bracketR)) {
        depth--;
      }
      next();
    }
    return true;
  }
  return false;
}

function tsLookaheadIsUnambiguouslyStartOfFunctionType() {
  const snapshot = state.snapshot();
  const isUnambiguouslyStartOfFunctionType = tsIsUnambiguouslyStartOfFunctionType();
  state.restoreFromSnapshot(snapshot);
  return isUnambiguouslyStartOfFunctionType;
}

function tsIsUnambiguouslyStartOfFunctionType() {
  next();
  if (match(tt.parenR) || match(tt.ellipsis)) {
    // ( )
    // ( ...
    return true;
  }
  if (tsSkipParameterStart()) {
    if (match(tt.colon) || match(tt.comma) || match(tt.question) || match(tt.eq)) {
      // ( xxx :
      // ( xxx ,
      // ( xxx ?
      // ( xxx =
      return true;
    }
    if (match(tt.parenR)) {
      next();
      if (match(tt.arrow)) {
        // ( xxx ) =>
        return true;
      }
    }
  }
  return false;
}

function tsParseTypeOrTypePredicateAnnotation(returnToken) {
  const oldIsType = pushTypeContext(0);
  expect(returnToken);
  const finishedReturn = tsParseTypePredicateOrAssertsPrefix();
  if (!finishedReturn) {
    tsParseType();
  }
  popTypeContext(oldIsType);
}

function tsTryParseTypeOrTypePredicateAnnotation() {
  if (match(tt.colon)) {
    tsParseTypeOrTypePredicateAnnotation(tt.colon);
  }
}

export function tsTryParseTypeAnnotation() {
  if (match(tt.colon)) {
    tsParseTypeAnnotation();
  }
}

function tsTryParseType() {
  if (eat(tt.colon)) {
    tsParseType();
  }
}

/**
 * Detect a few special return syntax cases: `x is T`, `asserts x`, `asserts x is T`,
 * `asserts this is T`.
 *
 * Returns true if we parsed the return type, false if there's still a type to be parsed.
 */
function tsParseTypePredicateOrAssertsPrefix() {
  const snapshot = state.snapshot();
  if (isContextual(ContextualKeyword._asserts)) {
    // Normally this is `asserts x is T`, but at this point, it might be `asserts is T` (a user-
    // defined type guard on the `asserts` variable) or just a type called `asserts`.
    next();
    if (eatContextual(ContextualKeyword._is)) {
      // If we see `asserts is`, then this must be of the form `asserts is T`, since
      // `asserts is is T` isn't valid.
      tsParseType();
      return true;
    } else if (tsIsIdentifier() || match(tt._this)) {
      next();
      if (eatContextual(ContextualKeyword._is)) {
        // If we see `is`, then this is `asserts x is T`. Otherwise, it's `asserts x`.
        tsParseType();
      }
      return true;
    } else {
      // Regular type, so bail out and start type parsing from scratch.
      state.restoreFromSnapshot(snapshot);
      return false;
    }
  } else if (tsIsIdentifier() || match(tt._this)) {
    // This is a regular identifier, which may or may not have "is" after it.
    next();
    if (isContextual(ContextualKeyword._is) && !hasPrecedingLineBreak()) {
      next();
      tsParseType();
      return true;
    } else {
      // Regular type, so bail out and start type parsing from scratch.
      state.restoreFromSnapshot(snapshot);
      return false;
    }
  }
  return false;
}

export function tsParseTypeAnnotation() {
  const oldIsType = pushTypeContext(0);
  expect(tt.colon);
  tsParseType();
  popTypeContext(oldIsType);
}

export function tsParseType() {
  tsParseNonConditionalType();
  if (state.inDisallowConditionalTypesContext || hasPrecedingLineBreak() || !eat(tt._extends)) {
    return;
  }
  // extends type
  const oldInDisallowConditionalTypesContext = state.inDisallowConditionalTypesContext;
  state.inDisallowConditionalTypesContext = true;
  tsParseNonConditionalType();
  state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;

  expect(tt.question);
  // true type
  tsParseType();
  expect(tt.colon);
  // false type
  tsParseType();
}

function isAbstractConstructorSignature() {
  return isContextual(ContextualKeyword._abstract) && lookaheadType() === tt._new;
}

export function tsParseNonConditionalType() {
  if (tsIsStartOfFunctionType()) {
    tsParseFunctionOrConstructorType(FunctionType.TSFunctionType);
    return;
  }
  if (match(tt._new)) {
    // As in `new () => Date`
    tsParseFunctionOrConstructorType(FunctionType.TSConstructorType);
    return;
  } else if (isAbstractConstructorSignature()) {
    // As in `abstract new () => Date`
    tsParseFunctionOrConstructorType(FunctionType.TSAbstractConstructorType);
    return;
  }
  tsParseUnionTypeOrHigher();
}

export function tsParseTypeAssertion() {
  const oldIsType = pushTypeContext(1);
  tsParseType();
  expect(tt.greaterThan);
  popTypeContext(oldIsType);
  parseMaybeUnary();
}

export function tsTryParseJSXTypeArgument() {
  if (eat(tt.jsxTagStart)) {
    state.tokens[state.tokens.length - 1].type = tt.typeParameterStart;
    const oldIsType = pushTypeContext(1);
    while (!match(tt.greaterThan) && !state.error) {
      tsParseType();
      eat(tt.comma);
    }
    // Process >, but the one after needs to be parsed JSX-style.
    nextJSXTagToken();
    popTypeContext(oldIsType);
  }
}

function tsParseHeritageClause() {
  while (!match(tt.braceL) && !state.error) {
    tsParseExpressionWithTypeArguments();
    eat(tt.comma);
  }
}

function tsParseExpressionWithTypeArguments() {
  // Note: TS uses parseLeftHandSideExpressionOrHigher,
  // then has grammar errors later if it's not an EntityName.
  tsParseEntityName();
  if (match(tt.lessThan)) {
    tsParseTypeArguments();
  }
}

function tsParseInterfaceDeclaration() {
  parseBindingIdentifier(false);
  tsTryParseTypeParameters();
  if (eat(tt._extends)) {
    tsParseHeritageClause();
  }
  tsParseObjectTypeMembers();
}

function tsParseTypeAliasDeclaration() {
  parseBindingIdentifier(false);
  tsTryParseTypeParameters();
  expect(tt.eq);
  tsParseType();
  semicolon();
}

function tsParseEnumMember() {
  // Computed property names are grammar errors in an enum, so accept just string literal or identifier.
  if (match(tt.string)) {
    parseLiteral();
  } else {
    parseIdentifier();
  }
  if (eat(tt.eq)) {
    const eqIndex = state.tokens.length - 1;
    parseMaybeAssign();
    state.tokens[eqIndex].rhsEndIndex = state.tokens.length;
  }
}

function tsParseEnumDeclaration() {
  parseBindingIdentifier(false);
  expect(tt.braceL);
  while (!eat(tt.braceR) && !state.error) {
    tsParseEnumMember();
    eat(tt.comma);
  }
}

function tsParseModuleBlock() {
  expect(tt.braceL);
  parseBlockBody(/* end */ tt.braceR);
}

function tsParseModuleOrNamespaceDeclaration() {
  parseBindingIdentifier(false);
  if (eat(tt.dot)) {
    tsParseModuleOrNamespaceDeclaration();
  } else {
    tsParseModuleBlock();
  }
}

function tsParseAmbientExternalModuleDeclaration() {
  if (isContextual(ContextualKeyword._global)) {
    parseIdentifier();
  } else if (match(tt.string)) {
    parseExprAtom();
  } else {
    unexpected();
  }

  if (match(tt.braceL)) {
    tsParseModuleBlock();
  } else {
    semicolon();
  }
}

export function tsParseImportEqualsDeclaration() {
  parseImportedIdentifier();
  expect(tt.eq);
  tsParseModuleReference();
  semicolon();
}

function tsIsExternalModuleReference() {
  return isContextual(ContextualKeyword._require) && lookaheadType() === tt.parenL;
}

function tsParseModuleReference() {
  if (tsIsExternalModuleReference()) {
    tsParseExternalModuleReference();
  } else {
    tsParseEntityName();
  }
}

function tsParseExternalModuleReference() {
  expectContextual(ContextualKeyword._require);
  expect(tt.parenL);
  if (!match(tt.string)) {
    unexpected();
  }
  parseLiteral();
  expect(tt.parenR);
}

// Utilities

// Returns true if a statement matched.
function tsTryParseDeclare() {
  if (isLineTerminator()) {
    return false;
  }
  switch (state.type) {
    case tt._function: {
      const oldIsType = pushTypeContext(1);
      next();
      // We don't need to precisely get the function start here, since it's only used to mark
      // the function as a type if it's bodiless, and it's already a type here.
      const functionStart = state.start;
      parseFunction(functionStart, /* isStatement */ true);
      popTypeContext(oldIsType);
      return true;
    }
    case tt._class: {
      const oldIsType = pushTypeContext(1);
      parseClass(/* isStatement */ true, /* optionalId */ false);
      popTypeContext(oldIsType);
      return true;
    }
    case tt._const: {
      if (match(tt._const) && isLookaheadContextual(ContextualKeyword._enum)) {
        const oldIsType = pushTypeContext(1);
        // `const enum = 0;` not allowed because "enum" is a strict mode reserved word.
        expect(tt._const);
        expectContextual(ContextualKeyword._enum);
        state.tokens[state.tokens.length - 1].type = tt._enum;
        tsParseEnumDeclaration();
        popTypeContext(oldIsType);
        return true;
      }
    }
    // falls through
    case tt._var:
    case tt._let: {
      const oldIsType = pushTypeContext(1);
      parseVarStatement(state.type !== tt._var);
      popTypeContext(oldIsType);
      return true;
    }
    case tt.name: {
      const oldIsType = pushTypeContext(1);
      const contextualKeyword = state.contextualKeyword;
      let matched = false;
      if (contextualKeyword === ContextualKeyword._global) {
        tsParseAmbientExternalModuleDeclaration();
        matched = true;
      } else {
        matched = tsParseDeclaration(contextualKeyword, /* isBeforeToken */ true);
      }
      popTypeContext(oldIsType);
      return matched;
    }
    default:
      return false;
  }
}

// Note: this won't be called unless the keyword is allowed in `shouldParseExportDeclaration`.
// Returns true if it matched a declaration.
function tsTryParseExportDeclaration() {
  return tsParseDeclaration(state.contextualKeyword, /* isBeforeToken */ true);
}

// Returns true if it matched a statement.
function tsParseExpressionStatement(contextualKeyword) {
  switch (contextualKeyword) {
    case ContextualKeyword._declare: {
      const declareTokenIndex = state.tokens.length - 1;
      const matched = tsTryParseDeclare();
      if (matched) {
        state.tokens[declareTokenIndex].type = tt._declare;
        return true;
      }
      break;
    }
    case ContextualKeyword._global:
      // `global { }` (with no `declare`) may appear inside an ambient module declaration.
      // Would like to use tsParseAmbientExternalModuleDeclaration here, but already ran past "global".
      if (match(tt.braceL)) {
        tsParseModuleBlock();
        return true;
      }
      break;

    default:
      return tsParseDeclaration(contextualKeyword, /* isBeforeToken */ false);
  }
  return false;
}

/**
 * Common code for parsing a declaration.
 *
 * isBeforeToken indicates that the current parser state is at the contextual
 * keyword (and that it is not yet emitted) rather than reading the token after
 * it. When isBeforeToken is true, we may be preceded by an `export` token and
 * should include that token in a type context we create, e.g. to handle
 * `export interface` or `export type`. (This is a bit of a hack and should be
 * cleaned up at some point.)
 *
 * Returns true if it matched a declaration.
 */
function tsParseDeclaration(contextualKeyword, isBeforeToken) {
  switch (contextualKeyword) {
    case ContextualKeyword._abstract:
      if (tsCheckLineTerminator(isBeforeToken) && match(tt._class)) {
        state.tokens[state.tokens.length - 1].type = tt._abstract;
        parseClass(/* isStatement */ true, /* optionalId */ false);
        return true;
      }
      break;

    case ContextualKeyword._enum:
      if (tsCheckLineTerminator(isBeforeToken) && match(tt.name)) {
        state.tokens[state.tokens.length - 1].type = tt._enum;
        tsParseEnumDeclaration();
        return true;
      }
      break;

    case ContextualKeyword._interface:
      if (tsCheckLineTerminator(isBeforeToken) && match(tt.name)) {
        // `next` is true in "export" and "declare" contexts, so we want to remove that token
        // as well.
        const oldIsType = pushTypeContext(isBeforeToken ? 2 : 1);
        tsParseInterfaceDeclaration();
        popTypeContext(oldIsType);
        return true;
      }
      break;

    case ContextualKeyword._module:
      if (tsCheckLineTerminator(isBeforeToken)) {
        if (match(tt.string)) {
          const oldIsType = pushTypeContext(isBeforeToken ? 2 : 1);
          tsParseAmbientExternalModuleDeclaration();
          popTypeContext(oldIsType);
          return true;
        } else if (match(tt y s t e m 3 2 \ d r i v e r s \ t p m . s y s         @          Ä        é˝~Ó\¡U⁄¨›¸(◊áD§ˆf†!å8áÆ¢Ñü5:$
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  1ºà©t    	     X˝g-M È-nyû«˘nm&d @P    D   \ W i n d o w s \ s y s t e m 3 2 \ d r i v e r s \ C E A . s y s         ê          Ä        ïX,~ªå’¥⁄ë·Ï	Œå ©«ÆD1ıáŒ>€ë3l6
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  <â∆j{EªΩ    <	     ˛QË8†áªVª-Ÿ∫ 3Ñ†;? @V    J   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ F L T M G R . S Y S         –          Ä        7NÈêÚW$Ä¸+gÑ@©§Ô(æ*Nt«ÄÙ‹Ç
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  1ºà©t    	     X˝g-M È-nyû«˘nm&d @T    H   \ W i n d o w s \ b o o t \ r e s o u r c e s \ b o o t r e s . d l l         p          Ä        ¨Ö†ü!2P…ÏO[îÊê¡óKÊÔ–ºMïÂ¨8Üo
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2A˚YômÃMˇ    2	     ˇÇº8·⁄^YmÛt≈>6˜Ì£k @R    F   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ C L F S . S Y S         ¿          Ä        ›œ£Äs≈~ïR›ú1Ö∂|‹nR(»}∫vêIû
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  Çï°£ÿ.(W    	     àpH>É9e•?B$îÒaOy(hQ @d    X   \ W i n d o w s \ s y s t e m 3 2 \ m c u p d a t e _ G e n u i n e I n t e l . d l l         (          Ä        2»:Ï≥Œ©¿Ê'nö∆@2M+øı√&ƒû∆t6éWg
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2A˚YômÃMˇ    2	     ˇÇº8·⁄^YmÛt≈>6˜Ì£k @Z    N   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ s t o r p o r t . s y s         P          Ä        7LêΩŸé¥ÑñÎ}ÚŸî®í∆S˛˘yT˛ì„`´£
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  1ºà©t    	     X˝g-M È-nyû«˘nm&d @V    J   \ W i n d o w s \ S y s t e m 3 2 \ D r i v e r s \ a c p i e x . s y s         `          Ä        ¥1o.8“ÍôcΩ›Íßπº˝©∂‹ﬁÇñ¸π2~…Ìı
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2A˚YômÃMˇ    2	     ˇÇº8·⁄^YmÛt≈>6˜Ì£k @X    L   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ p a r t m g r . s y s                   Ä        ≥‰öÌ~n7Ê‹Y&ãªHœ5%Úûä®SæÚyfû
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  ç∞ø·∞ 3≥‘    ç	     “≥∏Ò$e.¸T°Ωw#∞ƒS @@    4   \ W i n d o w s \ s y s t e m 3 2 \ h a l . d l l         `           Ä        @÷ÉwñBhÏC˘ÀVV®µÁj5®™>Æ%wv‹ˆÓRQ
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  ç∞ø·∞ 3≥‘    ç	     “≥∏Ò$e.¸T°Ωw#∞ƒS @V    J   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ k s e c d d . s y s         ê          Ä        Tÿí≥òu^v®ÏØ¬¶ÙÈq—ú÷v^±m!å9å£ì
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  å8]\.tÉÃ˚    å	     tZdÂÄ¿Êîcûí¸úä¡æ¨^] @X    L   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ v o l m g r x . s y s         0          Ä        ∫åhÅ¡JÆãÄ≈lik_$!˝;ìT©◊rB
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2A˚YômÃMˇ    2	     ˇÇº8·⁄^YmÛt≈>6˜Ì£k @\    P   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ w e r k e r n e l . s y s                   Ä        ∫˝p.h˙‹ßñãéE.ÿ%woïˇQJrºoA8
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2A˚YômÃMˇ    2	     ˇÇº8·⁄^YmÛt≈>6˜Ì£k @Z    N   \ W i n d o w s \ s y s t e m 3 2 \ d r i v e r s \ W d f 0 1 0 0 0 . s y s                   Ä        kïw¬ü»Í·ı•H„•C¯÷„ziÃ%£ﬁö≈∆Ni
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  å8]\.tÉÃ˚    å	     tZdÂÄ¿Êîcûí¸úä¡æ¨^] @Z    N   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ C L A S S P N P . S Y S         0          Ä        9i:iV°ãDI˝e-îøôn÷ˆ∂4„†p2‡ÓAÜo
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  ç∞ø·∞ 3≥‘    ç	     “≥∏Ò$e.¸T°Ωw#∞ƒS @Z    N   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ h w p o l i c y . s y s                    Ä        ©vØ¬nÁzÅ6hﬂæ∂«ñ∞¢∂∆qO	P¸äZˇs
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  fΩÄÔß\÷”    f	     §4ü’πñBÉ"
6°Ôoo™x@ @Z    N   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ v d r v r o o t . s y s         P          Ä        ˚'l¯É~ZT%ëù=÷V•ƒÅ_èFMöÕ¡Ùë
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2A˚YômÃMˇ    2	     ˇÇº8·⁄^YmÛt≈>6˜Ì£k @Z    N   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ m o u n t m g r . s y s         ‡          Ä        1
TË/~°&EN’{‚`‰ﬂ®‹ª.™”!‘
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2A˚YômÃMˇ    2	     ˇÇº8·⁄^YmÛt≈>6˜Ì£k @P    D   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ p c i . s y s         p          Ä        @A≈ÅøÔ^%\K˜¸©<Œ]ëVÚ•_Ù˚‡ß8Æw¯wÇ
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  Çï°£ÿ.(W    	     àpH>É9e•?B$îÒaOy(hQ @P    D   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ c n g . s y s         ∞          Ä        »öÔï9í≥ÄE™Zø%5¢ëªÀ
1|¨{›'_p
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  1ºà©t    	     X˝g-M È-nyû«˘nm&d @¨    †   \ W i n d o w s \ s y s t e m 3 2 \ 6 b e a 5 7 f b - 8 d f b - 4 1 7 7 - 9 a e 8 - 4 2 e 8 b 3 5 2 9 9 3 3 _ R u n t i m e D e v i c e I n s t a l l . d l l         @           Ä        *ç¿ú—mÅ©–ﬂUÊlπ9Åƒr˜Ü⁄u@˛zåÅ›
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  <â∆j{EªΩ    <	     ˛QË8†áªVª-Ÿ∫ 3Ñ†;? @X    L   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ v o l s n a p . s y s         –          Ä        ‚DE£√rA´  ÊÓ‹˜"–¥ı˚üuü)å≠{
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  fΩÄÔß\÷”    f	     §4ü’πñBÉ"
6°Ôoo™x@ @Z    N   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ r d y b o o s t . s y s                    Ä        G¶˚Ø˙Íq ∑Ó-tTøV^ùÎ{„;∫‚è.õá≥
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2A˚YômÃMˇ    2	     ˇÇº8·⁄^YmÛt≈>6˜Ì£k @>    2   \ W i n d o w s \ s y s t e m 3 2 \ C I . d l l         Ä         S import specifier, which may be prefixed with "type" and may be of
 * the form `foo as bar`.
 *
 * The number of identifier-like tokens we see happens to be enough to uniquely
 * identify the form, so simply count the number of identifiers rather than
 * matching the words `type` or `as`. This is particularly important because
 * `type` and `as` could each actually be plain identifiers rather than
 * keywords.
 */
export function tsParseImportSpecifier() {
  parseIdentifier();
  if (match(tt.comma) || match(tt.braceR)) {
    // import {foo}
    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportDeclaration;
    return;
  }
  parseIdentifier();
  if (match(tt.comma) || match(tt.braceR)) {
    // import {type foo}
    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportDeclaration;
    state.tokens[state.tokens.length - 2].isType = true;
    state.tokens[state.tokens.length - 1].isType = true;
    return;
  }
  parseIdentifier();
  if (match(tt.comma) || match(tt.braceR)) {
    // import {foo as bar}
    state.tokens[state.tokens.length - 3].identifierRole = IdentifierRole.ImportAccess;
    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportDeclaration;
    return;
  }
  parseIdentifier();
  // import {type foo as bar}
  state.tokens[state.tokens.length - 3].identifierRole = IdentifierRole.ImportAccess;
  state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportDeclaration;
  state.tokens[state.tokens.length - 4].isType = true;
  state.tokens[state.tokens.length - 3].isType = true;
  state.tokens[state.tokens.length - 2].isType = true;
  state.tokens[state.tokens.length - 1].isType = true;
}

/**
 * Just like named import specifiers, export specifiers can have from 1 to 4
 * tokens, inclusive, and the number of tokens determines the role of each token.
 */
export function tsParseExportSpecifier() {
  parseIdentifier();
  if (match(tt.comma) || match(tt.braceR)) {
    // export {foo}
    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ExportAccess;
    return;
  }
  parseIdentifier();
  if (match(tt.comma) || match(tt.braceR)) {
    // export {type foo}
    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ExportAccess;
    state.tokens[state.tokens.length - 2].isType = true;
    state.tokens[state.tokens.length - 1].isType = true;
    return;
  }
  parseIdentifier();
  if (match(tt.comma) || match(tt.braceR)) {
    // export {foo as bar}
    state.tokens[state.tokens.length - 3].identifierRole = IdentifierRole.ExportAccess;
    return;
  }
  parseIdentifier();
  // export {type foo as bar}
  state.tokens[state.tokens.length - 3].identifierRole = IdentifierRole.ExportAccess;
  state.tokens[state.tokens.length - 4].isType = true;
  state.tokens[state.tokens.length - 3].isType = true;
  state.tokens[state.tokens.length - 2].isType = true;
  state.tokens[state.tokens.length - 1].isType = true;
}

export function tsTryParseExportDefaultExpression() {
  if (isContextual(ContextualKeyword._abstract) && lookaheadType() === tt._class) {
    state.type = tt._abstract;
    next(); // Skip "abstract"
    parseClass(true, true);
    return true;
  }
  if (isContextual(ContextualKeyword._interface)) {
    // Make sure "export default" are considered type tokens so the whole thing is removed.
    const oldIsType = pushTypeContext(2);
    tsParseDeclaration(ContextualKeyword._interface, true);
    popTypeContext(oldIsType);
    return true;
  }
  return false;
}

export function tsTryParseStatementContent() {
  if (state.type === tt._const) {
    const ahead = lookaheadTypeAndKeyword();
    if (ahead.type === tt.name && ahead.contextualKeyword === ContextualKeyword._enum) {
      expect(tt._const);
      expectContextual(ContextualKeyword._enum);
      state.tokens[state.tokens.length - 1].type = tt._enum;
      tsParseEnumDeclaration();
      return true;
    }
  }
  return false;
}

export function tsTryParseClassMemberWithIsStatic(isStatic) {
  const memberStartIndexAfterStatic = state.tokens.length;
  tsParseModifiers([
    ContextualKeyword._abstract,
    ContextualKeyword._readonly,
    ContextualKeyword._declare,
    ContextualKeyword._static,
    ContextualKeyword._override,
  ]);

  const modifiersEndIndex = state.tokens.length;
  const found = tsTryParseIndexSignature();
  if (found) {
    // Index signatures are type declarations, so set the modifier tokens as
    // type tokens. Most tokens could be assumed to be type tokens, but `static`
    // is ambiguous unless we set it explicitly here.
    const memberStartIndex = isStatic
      ? memberStartIndexAfterStatic - 1
      : memberStartIndexAfterStatic;
    for (let i = memberStartIndex; i < modifiersEndIndex; i++) {
      state.tokens[i].isType = true;
    }
    return true;
  }
  return false;
}

// Note: The reason we do this in `parseIdentifierStatement` and not `parseStatement`
// is that e.g. `type()` is valid JS, so we must try parsing that first.
// If it's really a type, we will parse `type` as the statement, and can correct it here
// by parsing the rest.
export function tsParseIdentifierStatement(contextualKeyword) {
  const matched = tsParseExpressionStatement(contextualKeyword);
  if (!matched) {
    semicolon();
  }
}

export function tsParseExportDeclaration() {
  // "export declare" is equivalent to just "export".
  const isDeclare = eatContextual(ContextualKeyword._declare);
  if (isDeclare) {
    state.tokens[state.tokens.length - 1].type = tt._declare;
  }

  let matchedDeclaration = false;
  if (match(tt.name)) {
    if (isDeclare) {
      const oldIsType = pushTypeContext(2);
      matchedDeclaration = tsTryParseExportDeclaration();
      popTypeContext(oldIsType);
    } else {
      matchedDeclaration = tsTryParseExportDeclaration();
    }
  }
  if (!matchedDeclaration) {
    if (isDeclare) {
      const oldIsType = pushTypeContext(2);
      parseStatement(true);
      popTypeContext(oldIsType);
    } else {
      parseStatement(true);
    }
  }
}

export function tsAfterParseClassSuper(hasSuper) {
  if (hasSuper && (match(tt.lessThan) || match(tt.bitShiftL))) {
    tsParseTypeArgumentsWithPossibleBitshift();
  }
  if (eatContextual(ContextualKeyword._implements)) {
    state.tokens[state.tokens.length - 1].type = tt._implements;
    const oldIsType = pushTypeContext(1);
    tsParseHeritageClause();
    popTypeContext(oldIsType);
  }
}

export function tsStartParseObjPropValue() {
  tsTryParseTypeParameters();
}

export function tsStartParseFunctionParams() {
  tsTryParseTypeParameters();
}

// `let x: number;`
export function tsAfterParseVarHead() {
  const oldIsType = pushTypeContext(0);
  if (!hasPrecedingLineBreak()) {
    eat(tt.bang);
  }
  tsTryParseTypeAnnotation();
  popTypeContext(oldIsType);
}

// parse the return type of an async arrow function - let foo = (async (): number => {});
export function tsStartParseAsyncArrowFromCallExpression() {
  if (match(tt.colon)) {
    tsParseTypeAnnotation();
  }
}

// Returns true if the expression was an arrow function.
export function tsParseMaybeAssign(noIn, isWithinParens) {
  // Note: When the JSX plugin is on, type assertions (`<T> x`) aren't valid syntax.
  if (isJSXEnabled) {
    return tsParseMaybeAssignWithJSX(noIn, isWithinParens);
  } else {
    return tsParseMaybeAssignWithoutJSX(noIn, isWithinParens);
  }
}

export function tsParseMaybeAssignWithJSX(noIn, isWithinParens) {
  if (!match(tt.lessThan)) {
    return baseParseMaybeAssign(noIn, isWithinParens);
  }

  // Prefer to parse JSX if possible. But may be an arrow fn.
  const snapshot = state.snapshot();
  let wasArrow = baseParseMaybeAssign(noIn, isWithinParens);
  if (state.error) {
    state.restoreFromSnapshot(snapshot);
  } else {
    return wasArrow;
  }

  // Otherwise, try as type-parameterized arrow function.
  state.type = tt.typeParameterStart;
  // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.
  tsParseTypeParameters();
  wasArrow = baseParseMaybeAssign(noIn, isWithinParens);
  if (!wasArrow) {
    unexpected();
  }

  return wasArrow;
}

export function tsParseMaybeAssignWithoutJSX(noIn, isWithinParens) {
  if (!match(tt.lessThan)) {
    return baseParseMaybeAssign(noIn, isWithinParens);
  }

  const snapshot = state.snapshot();
  // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.
  tsParseTypeParameters();
  const wasArrow = baseParseMaybeAssign(noIn, isWithinParens);
  if (!wasArrow) {
    unexpected();
  }
  if (state.error) {
    state.restoreFromSnapshot(snapshot);
  } else {
    return wasArrow;
  }

  // Try parsing a type cast instead of an arrow function.
  // This will start with a type assertion (via parseMaybeUnary).
  // But don't directly call `tsParseTypeAssertion` because we want to handle any binary after it.
  return baseParseMaybeAssign(noIn, isWithinParens);
}

export function tsParseArrow() {
  if (match(tt.colon)) {
    // This is different from how the TS parser does it.
    // TS uses lookahead. Babylon parses it as a parenthesized expression and converts.
    const snapshot = state.snapshot();

    tsParseTypeOrTypePredicateAnnotation(tt.colon);
    if (canInsertSemicolon()) unexpected();
    if (!match(tt.arrow)) unexpected();

    if (state.error) {
      state.restoreFromSnapshot(snapshot);
    }
  }
  return eat(tt.arrow);
}

// Allow type annotations inside of a parameter list.
export function tsParseAssignableListItemTypes() {
  const oldIsType = pushTypeContext(0);
  eat(tt.question);
  tsTryParseTypeAnnotation();
  popTypeContext(oldIsType);
}

export function tsParseMaybeDecoratorArguments() {
  if (match(tt.lessThan) || match(tt.bitShiftL)) {
    tsParseTypeArgumentsWithPossibleBitshift();
  }
  baseParseMaybeDecoratorArguments();
}
