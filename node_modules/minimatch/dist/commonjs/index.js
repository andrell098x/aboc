"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.unescape = exports.escape = exports.AST = exports.Minimatch = exports.match = exports.makeRe = exports.braceExpand = exports.defaults = exports.filter = exports.GLOBSTAR = exports.sep = exports.minimatch = void 0;
const brace_expansion_1 = __importDefault(require("brace-expansion"));
const assert_valid_pattern_js_1 = require("./assert-valid-pattern.js");
const ast_js_1 = require("./ast.js");
const escape_js_1 = require("./escape.js");
const unescape_js_1 = require("./unescape.js");
const minimatch = (p, pattern, options = {}) => {
    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
    // shortcut: comments match nothing.
    if (!options.nocomment && pattern.charAt(0) === '#') {
        return false;
    }
    return new Minimatch(pattern, options).match(p);
};
exports.minimatch = minimatch;
// Optimized checking for the most common glob patterns.
const starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
const starDotExtTest = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);
const starDotExtTestDot = (ext) => (f) => f.endsWith(ext);
const starDotExtTestNocase = (ext) => {
    ext = ext.toLowerCase();
    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);
};
const starDotExtTestNocaseDot = (ext) => {
    ext = ext.toLowerCase();
    return (f) => f.toLowerCase().endsWith(ext);
};
const starDotStarRE = /^\*+\.\*+$/;
const starDotStarTest = (f) => !f.startsWith('.') && f.includes('.');
const starDotStarTestDot = (f) => f !== '.' && f !== '..' && f.includes('.');
const dotStarRE = /^\.\*+$/;
const dotStarTest = (f) => f !== '.' && f !== '..' && f.startsWith('.');
const starRE = /^\*+$/;
const starTest = (f) => f.length !== 0 && !f.startsWith('.');
const starTestDot = (f) => f.length !== 0 && f !== '.' && f !== '..';
const qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
const qmarksTestNocase = ([$0, ext = '']) => {
    const noext = qmarksTestNoExt([$0]);
    if (!ext)
        return noext;
    ext = ext.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
const qmarksTestNocaseDot = ([$0, ext = '']) => {
    const noext = qmarksTestNoExtDot([$0]);
    if (!ext)
        return noext;
    ext = ext.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
const qmarksTestDot = ([$0, ext = '']) => {
    const noext = qmarksTestNoExtDot([$0]);
    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
const qmarksTest = ([$0, ext = '']) => {
    const noext = qmarksTestNoExt([$0]);
    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
const qmarksTestNoExt = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && !f.startsWith('.');
};
const qmarksTestNoExtDot = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && f !== '.' && f !== '..';
};
/* c8 ignore start */
const defaultPlatform = (typeof process === 'object' && process
    ? (typeof process.env === 'object' &&
        process.env &&
        process.env.__MINIMATCH_TESTING_PLATFORM__) ||
        process.platform
    : 'posix');
const path = {
    win32: { sep: '\\' },
    posix: { sep: '/' },
};
/* c8 ignore stop */
exports.sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;
exports.minimatch.sep = exports.sep;
exports.GLOBSTAR = Symbol('globstar **');
exports.minimatch.GLOBSTAR = exports.GLOBSTAR;
// any single thing other than /
// don't need to escape / when using new RegExp()
const qmark = '[^/]';
// * => any number of characters
const star = qmark + '*?';
// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
const twoStarDot = '(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?';
// not a ^ or / followed by a dot,
// followed by anything, any number of times.
const twoStarNoDot = '(?:(?!(?:\\/|^)\\.).)*?';
const filter = (pattern, options = {}) => (p) => (0, exports.minimatch)(p, pattern, options);
exports.filter = filter;
exports.minimatch.filter = exports.filter;
const ext = (a, b = {}) => Object.assign({}, a, b);
const defaults = (def) => {
    if (!def || typeof def !== 'object' || !Object.keys(def).length) {
        return exports.minimatch;
    }
    const orig = exports.minimatch;
    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
    return Object.assign(m, {
        Minimatch: class Minimatch extends orig.Minimatch {
            constructor(pattern, options = {}) {
                super(pattern, ext(def, options));
            }
            static defaults(options) {
                return orig.defaults(ext(def, options)).Minimatch;
            }
        },
        AST: class AST extends orig.AST {
            /* c8 ignore start */
            constructor(type, parent, options = {}) {
                super(type, parent, ext(def, options));
            }
            /* c8 ignore stop */
            static fromGlob(pattern, options = {}) {
                return orig.AST.fromGlob(pattern, ext(def, options));
            }
        },
        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
        escape: (s, options = {}) => orig.escape(s, ext(def, options)),
        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
        defaults: (options) => orig.defaults(ext(def, options)),
        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
        sep: orig.sep,
        GLOBSTAR: exports.GLOBSTAR,
    });
};
exports.defaults = defaults;
exports.minimatch.defaults = exports.defaults;
// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
const braceExpand = (pattern, options = {}) => {
    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
    // Thanks to Yeting Li <https://github.com/yetingli> for
    // improving this regexp to avoid a ReDOS vulnerability.
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        // shortcut. no need to expand.
        return [pattern];
    }
    return (0, brace_expansion_1.default)(pattern);
};
exports.braceExpand = braceExpand;
exports.minimatch.braceExpand = exports.braceExpand;
// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
const makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
exports.makeRe = makeRe;
exports.minimatch.makeRe = exports.makeRe;
const match = (list, pattern, options = {}) => {
    const mm = new Minimatch(pattern, options);
    list = list.filter(f => mm.match(f));
    if (mm.options.nonull && !list.length) {
        list.push(pattern);
    }
    return list;
};
exports.match = match;
exports.minimatch.match = exports.match;
// replace stuff like \* with *
const globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
class Minimatch {
    options;
    set;
    pattern;
    windowsPathsNoEscape;
    nonegate;
    negate;
    comment;
    empty;
    preserveMultipleSlashes;
    partial;
    globSet;
    globParts;
    nocase;
    isWindows;
    platform;
    windowsNoMagicRoot;
    regexp;
    constructor(pattern, options = {}) {
        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
        options = options || {};
        this.options = options;
        this.pattern = pattern;
        this.platform = options.platform || defaultPlatform;
        this.isWindows = this.platform === 'win32';
        this.windowsPathsNoEscape =
            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
            this.pattern = this.pattern.replace(/\\/g, '/');
        }
        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
        this.regexp = null;
        this.negate = false;
        this.nonegate = !!options.nonegate;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.nocase = !!this.options.nocase;
        this.windowsNoMagicRoot =
            options.windowsNoMagicRoot !== undefined
                ? options.windowsNoMagicRoot
                : !!(this.isWindows && this.nocase);
        this.globSet = [];
        this.globParts = [];
        this.set = [];
        // make the set of regexps etc.
        this.make();
    }
    hasMagic() {
        if (this.options.magicalBraces && this.set.length > 1) {
            return true;
        }
        for (const pattern of this.set) {
            for (const part of pattern) {
                if (typeof part !== 'string')
                    return true;
            }
        }
        return false;
    }
    debug(..._) { }
    make() {
        const pattern = this.pattern;
        const options = this.options;
        // empty patterns and comments match nothing.
        if (!options.nocomment && pattern.charAt(0) === '#') {
            this.comment = true;
            return;
        }
        if (!pattern) {
            this.empty = true;
            return;
        }
        // step 1: figure out negation, etc.
        this.parseNegate();
        // step 2: expand braces
        this.globSet = [...new Set(this.braceExpand())];
        if (options.debug) {
            this.debug = (...args) => console.error(...args);
        }
        this.debug(this.pattern, this.globSet);
        // step 3: now we have a set, so turn each one into a series of
        // path-portion matching patterns.
        // These will be regexps, except in the case of "**", which is
        // set to the GLOBSTAR object for globstar behavior,
        // and will not contain any / characters
        //
        // First, we preprocess to make the glob pattern sets a bit simpler
        // and deduped.  There are some perf-killing patterns that can cause
        // problems with a glob walk, but we can simplify them down a bit.
        const rawGlobParts = this.globSet.map(s => this.slashSplit(s));
        this.globParts = this.preprocess(rawGlobParts);
        this.debug(this.pattern, this.globParts);
        // glob --> regexps
        let set = this.globParts.map((s, _, __) => {
            if (this.isWindows && this.windowsNoMagicRoot) {
                // check if it's a drive or unc path.
                const isUNC = s[0] === '' &&
                    s[1] === '' &&
                    (s[2] === '?' || !globMagic.test(s[2])) &&
                    !globMagic.test(s[3]);
                const isDrive = /^[a-z]:/i.test(s[0]);
                if (isUNC) {
                    return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];
                }
                else if (isDrive) {
                    return [s[0], ...s.slice(1).map(ss => this.parse(ss))];
                }
            }
            return s.map(ss => this.parse(ss));
        });
        this.debug(this.pattern, set);
        // filter out everything that didn't compile properly.
        this.set = set.filter(s => s.indexOf(false) === -1);
        // do not treat the ? in UNC paths as magic
        if (this.isWindows) {
            for (let i = 0; i < this.set.length; i++) {
                const p = this.set[i];
                if (p[0] === '' &&
                    p[1] === '' &&
                    this.globParts[i][2] === '?' &&
                    typeof p[3] === 'string' &&
                    /^[a-z]:$/i.test(p[3])) {
                    p[2] = '?';
                }
            }
        }
        this.debug(this.pattern, this.set);
    }
    // various transforms to equivalent pattern sets that are
    // faster to process in a filesystem walk.  The goal is to
    // eliminate what we can, and push all ** patterns as far
    // to the right as possible, even if it increases the number
    // of patterns that we have to process.
    preprocess(globParts) {
        // if we're not in globstar mode, then turn all ** into *
        if (this.options.noglobstar) {
            for (let i = 0; i < globParts.length; i++) {
                for (let j = 0; j < globParts[i].length; j++) {
                    if (globParts[i][j] === '**') {
                        globParts[i][j] = '*';
                    }
                }
            }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
            // aggressive optimization for the purpose of fs walking
            globParts = this.firstPhasePreProcess(globParts);
            globParts = this.secondPhasePreProcess(globParts);
        }
        else if (optimizationLevel >= 1) {
            // just basic optimizations to remove some .. parts
            globParts = this.levelOneOptimize(globParts);
        }
        else {
            // just collapse multiple ** portions into one
            globParts = this.adjascentGlobstarOptimize(globParts);
        }
        return globParts;
    }
    // just get rid of adjascent ** portions
    adjascentGlobstarOptimize(globParts) {
        return globParts.map(parts => {
            let gs = -1;
            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {
                let i = gs;
                while (parts[i + 1] === '**') {
                    i++;
                }
                if (i !== gs) {
                    parts.splice(gs, i - gs);
                }
            }
            return parts;
        });
    }
    // get rid of adjascent ** and resolve .. portions
    levelOneOptimize(globParts) {
        return globParts.map(parts => {
            parts = parts.reduce((set, part) => {
                const prev = set[set.length - 1];
                if (part === '**' && prev === '**') {
                    return set;
                }
                if (part === '..') {
                    if (prev && prev !== '..' && prev !== '.' && prev !== '**') {
                        set.pop();
                        return set;
                    }
                }
                set.push(part);
                return set;
            }, []);
            return parts.length === 0 ? [''] : parts;
        });
    }
    levelTwoFileOptimize(parts) {
        if (!Array.isArray(parts)) {
            parts = this.slashSplit(parts);
        }
        let didSomething = false;
        do {
            didSomething = false;
            // <pre>/<e>/<rest> -> <pre>/<rest>
            if (!this.preserveMultipleSlashes) {
                for (let i = 1; i < parts.length - 1; i++) {
                    const p = parts[i];
                    // don't squeeze out UNC patterns
                    if (i === 1 && p === '' && parts[0] === '')
                        continue;
                    if (p === '.' || p === '') {
                        didSomething = true;
                        parts.splice(i, 1);
                        i--;
                    }
                }
                if (parts[0] === '.' &&
                    parts.length === 2 &&
                    (parts[1] === '.' || parts[1] === '')) {
                    didSomething = true;
                    parts.pop();
                }
            }
            // <pre>/<p>/../<rest> -> <pre>/<rest>
            let dd = 0;
            while (-1 !== (dd = parts.indexOf('.Dğ
AL H‹JH…ÉuE‹æëI‹ÇHÿÀf9,Au÷L$E   H‹B H…Àu	¸   ‹ĞëI‹×HÿÂ@8,u÷¸   HĞH‹O(H…ÉuL‹ĞëM‹×IÿÂB8,u÷LĞH‹O0H…ÉuH‹ğëI‹÷HÿÆ@8,1u÷HğH‹O@H…ÉuL‹ØëM‹ßIÿÃB8,u÷LØH‹OxH…ÉuL‹ÈëM‹ÏIÿÁB8,	u÷LÈH‹OhH…ÉuL‹ÀëM‹ÇIÿÀB8,u÷LÀH‹_pH…ÛuM‹şëI‹ÏHÿÁf9,Ku÷L<M   H‹_PH…ÛuH‹ÈëHƒÉÿHÿÁ@8,u÷HÈH‹oXH…ítHƒËÿE3öHÿÃfD9t] uõL4]   I3íIßIØIÙIÛHŞIµ   H‹IÚHÚIÜH…ÉtE9u	I9˜   sEH…Ét3ƒÈÿğÁƒøu Hÿã9  D  L‹3ÒH‹ÈHÿ×9  D  H‰.H‰nL‹Ã3ÒH‹ÎènùÿÿH‹H‹VHHH÷ØMÒL#ÑIÒI‹ÂH÷ØHÛH#ÚM…Ò„Î   L‹GMMH‹ÓI‹Êè»  L‹G MM H‹ÓH‹Èè8  L‹G(MM(H‹ÓH‹Èè%  L‹G0MM0H‹ÓH‹Èè  L‹G@MM@H‹ÓH‹Èèÿ  L‹GxMMxH‹ÓH‹Èèì  L‹GhMMhH‹ÓH‹ÈèÙ  L‹GpMMpH‹ÓH‹Èè6  L‹GPMMPH‹ÓH‹Èè³  L‹GXMMXH‹ÓH‹Èè  H+Ø3ÒL‹ÃH‹Èè’"  H‹\$PH‹l$XH‹t$`HƒÄ A_A^A]A\_ÃÌÌÌÌÌÌÌH‰\$WHƒì H‹ÚH‹ùHÿA:  D  HOH‹ÓH¦1  H‰Hƒ¡    Hƒ¡˜    èjüÿÿHƒ§¸    H‹ÇHƒ§À    H‹\$0HƒÄ _ÃÌÌÌÌÌÌÌÌ@S¸0  è4"  H+àH‹ra  H3ÄH‰„$   H™¸   H‹H…ÀuZLAº   HŒ$   è6õÿÿLŒ$   º   L¾>  HL$ èXûÿÿHD$ IƒÈÿIÿÀB€<  uöIÿÀHT$ H‹Ëèa÷ÿÿH‹HHH÷ØHÀH#ÁH‹Œ$   H3Ìè	  HÄ0  [ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌH‰\$WHƒì ‹ÚH‹ùè,   öÃtH‹ÏHÿ9  D  H‹\$0H‹ÇHƒÄ _ÃÌÌÌÌÌÌÌÌÌÌ@SHƒì H‹ÙH‹‰¸   H…Ét@ƒÈÿğÁƒøu$Hÿ7  D  L‹ƒ¸   3ÒH‹ÈHÿø6  D  Hƒ£¸    Hƒ£À    H‹‹¨   H…Ét@ƒÈÿğÁƒøu$Hÿ¼6  D  L‹ƒ¨   3ÒH‹ÈHÿ¬6  D  Hƒ£¨    Hƒ£°    H‹ËHƒÄ [Hÿ%H8  ÌÌÌÌÌÌÌÌÌÌÌÌHƒì(H‹Ée  H…Àtÿf8  HƒÄ(ÃÌÌÌÌÌÌÌÌÌHƒì(3Ò3Éèé  ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌHìø   H‹ÑHL$ è„ıÿÿHMF  HL$ è±  ÌÌÌÌÌÌÌH‰\$WHƒì H‹úH‹ÙHÿ¥7  D  º€   H/  H‰E3ÀGCO(K(G8C8OHKHGXCXOhKhGxCx‡ˆ   DLLL‰ƒ¨   L‰ƒ°   H‹‡¨   H‹—°   H…ÀtH‰ƒ¨   H‰“°   ğÿ L‰ƒ¸   L‰ƒÀ   H‹‡¸   H‹À   H…ÀtH‰ƒ¸   H‰‹À   ğÿ H‹ÃH‹\$0HƒÄ _ÃÌÌÌÌÌÌÌÌÌÌ@SUVWATAUAVAWHƒìhH‹„$  E3ÒD‹´$à   M‹èH‹´$   D‹âH‹”$Ğ   L‹ùL‹„$Ø   A‹êH‹œ$   A‹Î‹¼$è   fD‰DˆL‰L$HH‰T$@L‰D$PH‰D$XE…ötOƒétAƒétƒùuI‹Ïè¬õÿÿë>…ÿx!¿œ€I‹Ï‰|$8L‰D$(M‹ÅH‰T$ A‹Ôè¥  ‹ÏèVõÿÿë‹Ïè-õÿÿë‹Ïèõÿÿ‹èD‰3¸   ‰{ğÁd  ÿÀ3ÿ‰CH‹„$ğ   H…Àtf98uH‹ÇH‰CHÿ€4  D  WÀL‰k0‰CH‹D$@H‰C H‹D$HH‰C(H‹D$PH‰ƒ€   H‹<c  D‰c8‰k<L‰»ˆ   H‰{@CHCXChH…Àtÿ«5  ëH‹ÇH‰CxH‹Ëb  H…ÀtH‹T$XA¸   H‹Ëÿ‚5  H‹£b  H…Àt	H‹Ëÿm5  H‹¶b  H…Àt	H‹ËÿX5  9{|Aƒş…Û   ÇCÿÿ €@8=Kb  uSH‹:b  H…Àtÿ'5  ¶ÈëHÿÛ2  D  …À‹Ï•Á…Éu%H‹b  H…Àtd@8=b  u[E3À3ÒH‹Ëÿè4  ëKH‹÷a  ½   H…Àt@8=ïa  uD‹ÅH‹ÖH‹Ëÿ½4  f9>uL‹ÃH‹ÕH‹ÎèîïÿÿH‹ÎHÿX2  D  @8=´a  tH‹Ãa  H…Àtÿ€4  HƒÄhA_A^A]A\_^][ÃÌèÕ  ÌÌÌÌÌÌÌÌÌ@SHìÀ   H‹Àa  H‹ÙH…ÀtÿB4  3ÒHL$ A¸˜   èş  H‹‹€   A¸   D‰D$8ÇD$ 	 ÀD‰D$$HÇD$@   H…ÉuHL$ è5óÿÿÌHcCE3ÀH‰D$H‹C8H‰L$0HL$ H‰D$PÇD$8   è	óÿÿÌÌÌÌÌÌÌÌÌ@SW¸(  è¿  H+àH‹ıZ  H3ÄH‰„$  ‹¼$p  L‹”$`  L‹œ$h  …ÿuHƒ=¿`   t³ë2ÛH„$€   H‰D$pH„$  H‰D$`H„$  H‰D$PHƒd$@ ‹„$x  ‰D$8‰|$0L‰\$(L‰T$ èüÿÿƒÿt…ÿt)H‹Œ$  H3Ìè‹  HÄ(  _[ÃÌHŒ$€   è›şÿÿÌ„ÛtH‹/`  H”$  HŒ$€   ÿÙ2  HŒ$€   èPúÿÿHŒ$€   è_şÿÿÌÌÌÌÌÌÌHƒìXƒd$H Hƒd$@ ‹„$˜   ‰D$8H‹„$ˆ   ÇD$0   H‰D$(H‹„$€   H‰D$ è³şÿÿHƒÄXÃÌÌÌÌÌÌÌÌÌÌH‰\$H‰l$H‰t$WHƒìP‹úH‹ñHÿ 0  D  H‹¬$ˆ   …Àu,ÇD$8œ€L7  H‰l$(E3ÉHƒd$  ‹×H‹ÎèXÿÿÿ¸œ  ·ØLé6  Ë  €‹×…ÀH‹ÎNØE3É‰\$8ÇD$0   H‰l$(Hƒd$  èşÿÿH‹l$h‹ÃH‹\$`H‹t$pHƒÄP_ÃÌÌÌÌÌÌÌHƒìHH‹D$HH‰D$(è9ÿÿÿHƒÄHÃÌÌÌÌÌÌÌÌ¹   Í)ÃÌÌÌÌÌÌÌÌfÃÌÌÌÌÌÌÌÌÌH‰\$H‰l$H‰t$WHƒìPH‹­X  H3ÄH‰D$H3Ò3ÉDBHÿf0  D  H‹ğH…ÀuH‹L$XP/èxÿÿÿ‹èé@  ½   H16  D‹ÅH‹ÎHÿ40  D  H‹ØH…ÀuH‹L$XU1è>ÿÿÿ‹èéã   ƒd$0 LL$0E3À3ÒH‹ËHÿ0  D  …Àt
½ÿÿ €é·   Hÿ.  D  ƒøztHÿ.  D  ·èÍ  €…ÀNèé‡   ‹T$0¹@   Hÿ.  D  D‹D$0LL$0H‹ĞH‹ËH‹øHÿ /  D  …ÀuH‹L$XPEè–şÿÿ‹èë*ƒu"@„-±]  tHD$8D‹ÍHÀ5  H‰D$ èrêÿÿ3íH…ÿtH‹ÏHÿ%.  D  H…ÛtH‹ËHÿ)/  D  H‹ÎHÿ/  D  ‹ÅH‹L$HH3ÌèN  H‹\$`H‹l$hH‹t$pHƒÄP_ÃÌÌÌÌÌÌÌÌÌH‹ÄH‰XH‰pL‰H L‰@WAVAWHƒì`I‹ùI‹ğL‹òL‹ùHƒ`Ø Hƒ`Ğ è]èÿÿ‹Ø…Ày
èşıÿÿé   HD$HH‰D$8L‰t$0L‰|$(HD$PH‰D$ L‹L\  E3À3ÒH¨(  HÿÙ,  D  H‹ØH‰D$X‰D$@…Àx@ë$·ÈÉ  €…ÀNÈ‹Ù‰L$@H‹¼$˜   H‹´$   …ÛxH‹D$PH‰H‹D$HH‰Hƒd$H H‹L$HHÿx.  D  ‹ÃL\$`I‹[ I‹s(I‹ãA_A^_ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌH‰\$WHƒì0H‹ùHƒd$H èlçÿÿ‹Ø…ÀyèıÿÿëJH‰|$HLL$HE3ÀAPHÓ'  Hÿ,  D  H‹ØH‰D$P‰D$ …Àxë·ÈÉ  €…ÀNÈ‹Ù‰L$ ‹ÃH‹\$@HƒÄ0_ÃÌÌÌÌÌÌÌÌL‹ÜSVWATAUAVAWHì   H‹XU  H3ÄH‰„$˜  L‰Œ$Ø   L‰„$   H‹ÂH‰”$Ğ   H‰Œ$¸   H‰”$à   L‰„$è   L‰Œ$ğ   H‹„$   H‰„$È   H‹´$  H‰´$ø   L‹´$  L‰´$   L‹¼$  L‰¼$  L‹¬$   L‰¬$  L‹¤$(  L‰¤$  3ÿH‰|$pI‰»ÀşÿÿI‰»°şÿÿ‰¼$€   ÇD$x   I‰»Èşÿÿ‰¼$„   I‰»Ğşÿÿ‰|$|èüåÿÿ‹Ø…Ày
èûÿÿé  H„$¨   H‰D$`HD$|H‰D$XHD$xH‰D$PH„$ˆ   H‰D$HHD$pH‰D$@H„$€   H‰D$8H„$    H‰D$0H„$„   H‰D$(H„$˜   H‰D$ L‹Œ$¸   E3ÀAPHö%  Hÿ'*  D  H‹ØH‰„$   ‰œ$À   èsãÿÿƒ=$S  vQ‰œ$°   H„$°   H‰„$ˆ  HÇ„$     H„$h  H‰D$(ÇD$    E3ÉE3ÀH\2  HÖR  èÅãÿÿH‹êR  ‰=ÄR  H‰=İR  Hÿæ*  D  …ÛyPö^Y  tB‰œ$   H„$   H‰„$8  HÇ„$@     H„$(  H‰D$ A¹   H1  èöåÿÿé¨  öY  tB‰œ$¸   H„$¸   H‰„$X  HÇ„$`     H„$H  H‰D$ A¹   H·0  è¦åÿÿëq·ÈÉ  €…ÀNÈ‹Ù‰Œ$À   3ÿH‹„$à   H‰„$Ğ   H‹„$è   H‰„$   H‹„$ğ   H‰„$Ø   H‹´$ø   L‹´$   L‹¼$  L‹¬$  L‹¤$  …Ûˆâ   H…öuH‹L$pHÿf*  D  H‰|$pëH‹D$pH‰M…öuH‹Œ$ˆ   Hÿ>*  D  ëH‹„$ˆ   I‰M…ÿt‹D$xA‰M…ätH‹„$¨   I‰$H‰¼$¨   M…ít‹D$|A‰E ‹„$€   H‹Œ$È   ‰H‹„$˜   H‹Œ$   H‰‹„$„   H‹Œ$Ğ   ‰H‹„$    H‹Œ$Ø   H‰H‰¼$˜   H‰¼$    H‰|$pH‰¼$ˆ   H‹Œ$˜   Hÿ†)  D  H‹Œ$    Hÿr)  D  H‹L$pHÿa)  D  H‹Œ$ˆ   HÿM)  D  H‹Œ$¨   Hÿ9)  D  ‹ÃH‹Œ$˜  H3Ìèú
  HÄ   A_A^A]A\_^[ÃÌÌÌÌÌÌÌHƒìXE3ÛL‹ÑH…ÉtMH…ÒtHƒ:0t¸W €ëAL‰\$HHJL‰\$@HB L‰\$8LJL‰\$0LBH‰D$(HƒÂH‰L$ I‹Êèêúÿÿë¸@ €HƒÄXÃÌÌÌÌÌÌÌÌÌÌH‰\$H‰t$WHƒìPH‹ñH…Ét]H…ÒtXƒ:Pt¸W €ëQHJHHB@H‰D$HLR8H‰L$@LZ L‰T$8HZ0L‰\$0Hz(LJH‰\$(LBH‰|$ HƒÂH‹Îèbúÿÿë¸@ €H‹\$`H‹t$hHƒÄP_ÃÌÌÌÌÌÌÌH‰\$VHìĞ   H‹¤O  H3ÄH‰„$È   H‹ñèáÿÿ‹Ø…Ày
è¾öÿÿéA  H‰t$ L‹%U  E3ÀAPH!  Hÿ°%  D  H‹ØH‰D$P‰\$Hèßÿÿ¾   95¯N  vN‰\$0HD$0H‰„$¸   ‰´$À   ƒ¤$Ä    H„$˜   H‰D$(ÇD$    E3ÉE3ÀH¼-  HdN  èSßÿÿH‹xN  ƒ%QN   Hƒ%iN   Hÿr&  D  …Ûy.öêT  tj‰\$8HD$8H‰D$h‰t$pƒd$t HD$XH,  ë5ö¼T  t<‰\$@HD$@H‰„$ˆ   ‰´$   ƒ¤$”    HD$xHf,  H‰D$ A¹   èZáÿÿë·ÈÉ  €…ÀNÈ‹Ù‰L$HHƒ=èS   tHßS  Hÿ`$  D  Hƒ%ËS   ‹ÃH‹Œ$È   H3Ìè1  H‹œ$è   HÄĞ   ^ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ@SHƒì H‹ÙH…ÉtNƒ90t¸W €ëDH‹IHÿ&  D  H‹K Hƒc Hÿş%  D  H‹KHƒc  Hÿé%  D  Hƒc ƒ# 3ÀHƒÄ [ÃÌÌÌÌÌÌÌÌÌÌÌÌ@SHƒì H‹ÙH…Ét|ƒ9Pt¸W €ërH‹IHÿ£%  D  H‹K0Hƒc Hÿ%  D  H‹KHƒc0 Hÿy%  D  H‹K Hÿi%  D  H‹K@Hƒc  Hƒc ƒ# HÿL%  D  Hƒc@ ƒcH 3ÀHƒÄ [ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌ@SHƒì E3ÒA‹ÚH…ÉtbA¸ÿÿÿH‹ÁA‹ĞfD9t
HƒÀHƒêuğH‹ÂH÷ØÛ÷ÓãW €H…ÒtL+ÂëM‹ÂH‹ÂH÷ØMÉM#ÈH…ÒtM…Éu»@ €ëHÿº$  D  ‹ÃHƒÄ [ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌHÿ%‰$  ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌHÿ%q$  ÌÌÌÌÌÌÌÌÌÌÌÌÌH‰\$H‰l$H‰t$WHƒì 3íI‹ÙH‹ùH;ÊtFM…ÀtAfA9(t;HƒÈÿHÿÀfA9,@uöH4E   H+×H;ÖrL‹ÎHÿ@$  D  H…ÛtH‰;H>ëH…ÛtI‰)H‹ÇH‹\$0H‹l$8H‹t$@HƒÄ _ÃÌÌÌÌÌÌÌÌÌH‰\$H‰t$WHƒì I‹ÙH‹ùH;ÊtAM…Àt<A€8 t6HƒÎÿHÿÆA€<0 uöHÿÆH+×H;ÖrL‹ÎHÿ¼#  D  H…ÛtH‰;H>ëH…ÛtIƒ! H‹ÇH‹\$0H‹t$8HƒÄ _ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌHƒì(¹   ÿ1#  H‰ŠQ  H‰{Q  H…Àu¸   ëHƒ  3ÀHƒÄ(ÃÌÌÌÌÌÌÌÌH‰\$H‰l$H‰t$ATAVAWHƒì 3ÛM‹ğL‹ù…Ò…ò   ‹µJ  …Àv  ÿÈD‹ó‰¢J  eH‹%0   H‹pëH;Æt¹è  ÿÃ!  3ÀğH±5àP  uãëA¾   ‹ØP  ƒøt¹   è[  éƒ  H‹-ÍP  H…ítdH‹5¹P  L‹åL‹şHƒîH;õr7H‹H…ÀtïH‰ÿ©"  H‹šP  H‹‹P  L;áuL;øtÎL‹áH‹éL‹øH‹ğëÀH‹Íÿ"  H‰cP  H‰dP  ‰NP  E…ö…  H‡6P  éø   ƒú…ï   eH‹%0   ‹ëH‹pëH;Æt¹è  ÿß   3ÀğH±5üO  uãë½   ‹õO  …Àt¹   èy  ë_H5&"  ÇÔO     L%%"  ‹ÃI;ôs#…ÀuH9t	H‹ÿÌ!  HƒÆI;ôrå…Àt3ÀëgHÜ!  Hµ!  èü  Ç†O     …íu
H‹ÃH‡pO  H9‰O  t(H€O  èS  …ÀtH‹pO  M‹Æº   I‹Ïÿ_!  ÿÑH  ¸   H‹\$@H‹l$HH‹t$PHƒÄ A_A^A\ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌH‰\$H‰t$WHƒì I‹ø‹ÚH‹ñƒúuès  L‹Ç‹ÓH‹ÎH‹\$0H‹t$8HƒÄ _é   ÌÌÌÌÌÌÌH‹ÄH‰X L‰@‰PH‰HVWAVHìP  ‹úL‹ñ¾   ‹Ş‰\$ ;Öw‰õG  …Òu9H  u3Û‰\$ éÚ  Bÿ;Æ‡   L‹ŒN  M…ÉtB‹õG  ;ÖDÆ‰êG  L‹„$€  I‹Áÿ]   ‹Ø‰D$ ë3Û‰\$ s‹¼$x  L‹´$p  …Û„y  L‹„$€  ‹×I‹Îè·üÿÿ‹Ø‰D$ ë3Û‰\$ s‹¼$x  L‹´$p  …Û„?  L‹„$€  ‹×I‹Îè1  ‹Ø‰D$ ë3Û‰\$ s‹¼$x  L‹´$p  ;ş…Š   …Û…‚   E3À3ÒI‹Îèô  ë¾   ‹¼$x  L‹´$p  ‹\$ E3À3ÒI‹Îèüÿÿë¾   ‹¼$x  L‹´$p  ‹\$ H‹lM  H…Àt(E3À3ÒI‹ÎÿQ  ë¾   ‹¼$x  L‹´$p  ‹\$ …ÿtƒÿurL‹„$€  ‹×I‹Îè°ûÿÿ‹Ø‰D$ ë3Û‰\$ s‹¼$x  L‹´$p  H‹ıL  H…Àt4ƒ=eF   t+L‹„$€  ‹×I‹ÎÿÔ  ‹Ø‰D$ ë3Û‰\$ s‹¼$x  ;şw
ÇöE  ÿÿÿÿ‹ÃH‹œ$ˆ  HÄP  A^_^ÃÌÌÌÌÌÌff„     H;ÑE  uHÁÁf÷ÁÿÿuÃHÁÉéR   ÌÌÌÌÌÌÿ%>  ÌÌÌÌÌÌ@SHƒì H‹Ù3Éÿ  H‹Ëÿ  ÿ˜  H‹Èº	 ÀHƒÄ [Hÿ%Œ  ÌÌÌÌÌÌÌÌÌÌÌÌH‰L$Hìˆ   H-F  ÿ—  H‹G  H‰D$HE3ÀHT$PH‹L$Hÿ€  H‰D$@Hƒ|$@ tBHÇD$8    HD$XH‰D$0HD$`H‰D$(H×E  H‰D$ L‹L$@L‹D$HH‹T$P3Éÿ;  ë#H‹JF  H‹ H‰ F  H‹9F  HƒÀH‰.F  H‹‡F  H‰øD  H‹„$   H‰ùE  ÇÏD  	 ÀÇÉD     ÇÓD     ¸   HkÀ HËD  HÇ   ¸   HkÀH³D  H‹TD  H‰¸   HkÀH˜D  H‹AD  H‰¸   HkÀ H‹%D  H‰Lh¸   HkÀH‹D  H‰LhH,  èWşÿÿHÄˆ   ÃÌÌÌÌÌÌÌ@SHƒì H‹ÙH‹ˆJ  H‰D$8HƒøÿuH‹Î  ÿx  HƒÄ [Ã¹   èÙ  H‹XJ  H‰D$8H‹DJ  H‰D$@LD$@HT$8H‹ËèÆ  H‹ØH‹T$8H‰&J  H‹T$@H‰J  ¹   è•  H‹Ãë›ÌÌÌÌÌÌÌHƒì(ècÿÿÿH÷ØÀ÷ØÿÈHƒÄ(ÃÌÌÌÌÌÌÿ%±  ÌÌÌÌÌÌÿ%  ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌH‰\$WHƒì ‹ÚH‹ùÿ+  öÃtH‹Ïè·ÿÿÿH‹\$0H‹ÇHƒÄ _ÃÌÌÌÌÌÌÿ%  ÌÌÌÌÌÌÿ%  ÌÌÌÌÌÌÌÌLcA<E3ÉLÁL‹ÒA·@E·XHƒÀIÀE…Ût‹PL;Òr
‹HÊL;ÑrAÿÁHƒÀ(E;Ërâ3ÀÃÌÌÌÌÌÌÌÌÌÌÌÌH‰\$WHƒì H‹ÙH=ŒÁÿÿH‹ÏèD   …Àt"H+ßH‹ÓH‹Ïè‚ÿÿÿH…Àt‹@$Áè÷Ğƒàë3ÀH‹\$0HƒÄ _ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ¸MZ  f9u HcA<HÁ8PE  u¹  f9Hu¸   Ã3ÀÃÌÌÌÌÌÌÌH‰\$ UH‹ìHƒì Hƒe H»2¢ß-™+  H‹ÁA  H;Ã…“   HMÿ&  H‹EH‰EÿÀ  ‹ÀH1Eÿ¼  ‹ÀH1Eÿ  ‹ÀHÁàH1Eÿø  ‹ÀHMH3EH3ÁHM H‰Eÿ•  ‹E H¹ÿÿÿÿÿÿ  HÁà H3E H3EH#ÁH‹ÈH;ÃuH¸3¢ß-™+  H‹ÈH‰%A  H‹\$HH÷ĞH‰A  HƒÄ ]ÃÌÌÌÌÌÌÌÌ¸   ÃÌÌÌÌÌÌÿ%  ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÂ  ÌÌÌÌÌÌÿ%ñ  ÌÌÌÌÌÌÿ%İ  ÌÌÌÌÌÌÿ%É  ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÿ%Ü  ÌÌÌÌÌÌÌÌHƒì(M‹A8H‹ÊI‹Ñè   ¸   HƒÄ(ÃÌÌÌÌÌÌÌ@SE‹H‹ÚAƒãøL‹ÉAö L‹ÑtA‹@McP÷ØLÑHcÈL#ÑIcÃJ‹H‹C‹HH‹CöDt¶DƒàğLÈL3ÊI‹É[éMúÿÿÌÌÌÌÌÌÌÌÌH‹ÄH‰XH‰hH‰pH‰x AVHƒì M‹Q8H‹òM‹ğH‹éI‹ÑH‹ÎI‹ùA‹HÁãIÚLCèZÿÿÿ‹E$föØ¸   Ò÷ÚĞ…StL‹ÏM‹ÆH‹ÖH‹ÍÿA  H‹\$0H‹l$8H‹t$@H‹|$HHƒÄ A^ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÿ%  ÌÌÌÌÌÌÌÌÌÌff„     ÿàÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌff„     HƒìL‰$L‰\$M3ÛLT$L+ĞMBÓeL‹%   M;ÓsfAâ ğM› ğÿÿE„M;ÓrñL‹$L‹\$HƒÄÃÌÌÌÌÌÌ@UHƒì@H‹êH‹‹Hÿ   D  HƒÄ@]ÃÌÌÌÌÌÌÌ@UHƒì H‹êH‹‹Hÿø  D  HƒÄ ]ÃÌÌÌÌÌÌÌ@UHƒìpH‹êH‹‹HÿĞ  D  HƒÄp]ÃÌÌÌÌÌÌÌ@UHƒì0H‹êH‹‹Hÿ¨  D  HƒÄ0]ÃÌÌÌÌÌÌÌ@UHƒì H‹êH‰  H‹‹‰•¤   H‰È   ‰U(‹E(=csmàuH‹•È   ‹M(è5ûÿÿ‰E0ëÇE0    ‹E0HƒÄ ]ÃÌ@UHƒì H‹êH‰  H‹‹‰•¨   H‰Ğ   ‰U8‹E8=csmàuH‹•Ğ   ‹M8èáúÿÿ‰E@ëÇE@    ‹E@HƒÄ ]ÃÌ@UHƒì H‹êH‰  H‹‹‰•¬   H‰Ø   ‰UH‹EH=csmàuH‹•Ø   ‹MHèúÿÿ‰EPëÇEP    ‹EPHƒÄ ]ÃÌ@UHƒì H‹êH‰   H‹‹‰•°   H‰à   ‰UX‹EX=csmàuH‹•à   ‹MXè9úÿÿ‰E`ëÇE`    ‹E`HƒÄ ]ÃÌ@UHƒì H‹êH‰(  H‹‹‰•´   H‰è   ‰Uh‹Eh=csmàuH‹•è   ‹Mhèåùÿÿ‰EpëÇEp    ‹EpHƒÄ ]ÃÌ@UHƒì H‹êH‰0  H‹‹‰•¸   H‰ğ   ‰Ux‹Ex=csmàuH‹•ğ   ‹Mxè‘ùÿÿ‰…€   ë
Ç…€       ‹…€   HƒÄ ]ÃÌ@UHƒì H‹êH‰8  H‹‹‰•¼   H‰ø   ‰•ˆ   ‹…ˆ   =csmàuH‹•ø   ‹ˆ   è+ùÿÿ‰…   ë
Ç…       ‹…   HƒÄ ]ÃÌ@UHƒì H‹êH‰@  H‹‹‰•À   H‰   ‰•˜   ‹…˜   =csmàuH‹•   ‹˜   èÅøÿÿ‰…    ë
Ç…        ‹…    HƒÄ ]ÃÌ@UHƒì H‹êƒ½x  w
Çd;  ÿÿÿÿHƒÄ ]ÃÌÌÌÌÌÌÌ@UHƒì H‹ê¹   èyúÿÿHƒÄ ]ÃÌÌÌÌÌÌÌÌÌÌÌÌÌ@UHƒì H‹êH‹3É8  À”Á‹ÁHƒÄ ]ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌHƒì(Hƒ=¬@   tH£@  Hÿ$  D  Hƒ%@   HƒÄ(ÃÌ  €   ° €   À= €           @R €   4 €   °4 €   €† €                                   ò[ €        
         n                                          ğR €             €   P €   A      °[ €          ¬[ €   up      „Z €   °      ]ˆŠëÉŸè +H`               ²Z €   ˆZ €   ò[ €                           3qqº¾7IƒµÛïœÌ6                       ğS €                                          @S €   !      pZ €   @    <   D         pà       T €         pZ €   ğ      up      Ô[ €   P             àS €          ĞS €           `   ùk[y¶—‰O½/B»¾™n    ]ˆŠëÉŸè +H`                                       ğR €          @ ,                r       PS €        pZ €   ğ      !      @S €    P €   ²Z €   ˆZ €   À[ €           Q €   A      Z €          ¬[ €   !        Z €   5 8                   àT €                                                                       ’      “       !        S €   !       ¸T €   T €   ÀQ €    U €    R €   @ 0       D         r       èP €        @S €         @S €          Q €   €      pZ €   ğ   (   A      xZ €          ¬[ €   up      ¨[ €   ğ      A      Ø[ €          ¬[ €           !        Z €   !       €T €   !        Z €   !       ÈP €   @ NX   D   ˆ         p@       R €           Q €   €     pZ €   P     R €   €     pZ €   P      àR €   €  (   àR €   €  0   °Q €      8   pZ €   P  @   (R €   €  H   pZ €   ğ   P                 lowee);
                        // found a match.
                        return true;
                    }
                    else {
                        // can't swallow "." or ".." ever.
                        // can only swallow ".foo" when explicitly asked.
                        if (swallowee === '.' ||
                            swallowee === '..' ||
                            (!options.dot && swallowee.charAt(0) === '.')) {
                            this.debug('dot detected!', file, fr, pattern, pr);
                            break;
                        }
                        // ** swallows a segment, and continue.
                        this.debug('globstar swallow a segment, and continue');
                        fr++;
                    }
                }
                // no match was found.
                // However, in partial mode, we can't say this is necessarily over.
                /* c8 ignore start */
                if (partial) {
                    // ran out of file
                    this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
                    if (fr === fl) {
                        return true;
                    }
                }
                /* c8 ignore stop */
                return false;
            }
            // something other than **
            // non-magic patterns just have to match exactly
            // patterns with magic have been turned into regexps.
            let hit;
            if (typeof p === 'string') {
                hit = f === p;
                this.debug('string match', p, f, hit);
            }
            else {
                hit = p.test(f);
                this.debug('pattern match', p, f, hit);
            }
            if (!hit)
                return false;
        }
        // Note: ending in / means that we'll get a final ""
        // at the end of the pattern.  This can only match a
        // corresponding "" at the end of the file.
        // If the file ends in /, then it can only match a
        // a pattern that ends in /, unless the pattern just
        // doesn't have any more for it. But, a/b/ should *not*
        // match "a/b/*", even though "" matches against the
        // [^/]*? pattern, except in partial mode, where it might
        // simply not be reached yet.
        // However, a/b/ should still satisfy a/*
        // now either we fell off the end of the pattern, or we're done.
        if (fi === fl && pi === pl) {
            // ran out of pattern and filename at the same time.
            // an exact hit!
            return true;
        }
        else if (fi === fl) {
            // ran out of file, but still had pattern left.
            // this is ok if we're doing the match as part of
            // a glob fs traversal.
            return partial;
        }
        else if (pi === pl) {
            // ran out of pattern, still have file left.
            // this is only acceptable if we're on the very last
            // empty segment of a file with a trailing slash.
            // a/* should match a/b/
            return fi === fl - 1 && file[fi] === '';
            /* c8 ignore start */
        }
        else {
            // should be unreachable.
            throw new Error('wtf?');
        }
        /* c8 ignore stop */
    }
    braceExpand() {
        return (0, exports.braceExpand)(this.pattern, this.options);
    }
    parse(pattern) {
        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
        const options = this.options;
        // shortcuts
        if (pattern === '**')
            return exports.GLOBSTAR;
        if (pattern === '')
            return '';
        // far and away, the most common glob pattern parts are
        // *, *.*, and *.<ext>  Add a fast check method for those.
        let m;
        let fastTest = null;
        if ((m = pattern.match(starRE))) {
            fastTest = options.dot ? starTestDot : starTest;
        }
        else if ((m = pattern.match(starDotExtRE))) {
            fastTest = (options.nocase
                ? options.dot
                    ? starDotExtTestNocaseDot
                    : starDotExtTestNocase
                : options.dot
                    ? starDotExtTestDot
                    : starDotExtTest)(m[1]);
        }
        else if ((m = pattern.match(qmarksRE))) {
            fastTest = (options.nocase
                ? options.dot
                    ? qmarksTestNocaseDot
                    : qmarksTestNocase
                : options.dot
                    ? qmarksTestDot
                    : qmarksTest)(m);
        }
        else if ((m = pattern.match(starDotStarRE))) {
            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
        }
        else if ((m = pattern.match(dotStarRE))) {
            fastTest = dotStarTest;
        }
        const re = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();
        if (fastTest && typeof re === 'object') {
            // Avoids overriding in frozen environments
            Reflect.defineProperty(re, 'test', { value: fastTest });
        }
        return re;
    }
    makeRe() {
        if (this.regexp || this.regexp === false)
            return this.regexp;
        // at this point, this.set is a 2d array of partial
        // pattern strings, or "**".
        //
        // It's better to use .match().  This function shouldn't
        // be used, really, but it's pretty convenient sometimes,
        // when you just want to work with a regex.
        const set = this.set;
        if (!set.length) {
            this.regexp = false;
            return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar
            ? star
            : options.dot
                ? twoStarDot
                : twoStarNoDot;
        const flags = new Set(options.nocase ? ['i'] : []);
        // regexpify non-globstar patterns
        // if ** is only item, then we just do one twoStar
        // if ** is first, and there are more, prepend (\/|twoStar\/)? to next
        // if ** is last, append (\/twoStar|) to previous
        // if ** is in the middle, append (\/|\/twoStar\/) to previous
        // then filter out GLOBSTAR symbols
        let re = set
            .map(pattern => {
            const pp = pattern.map(p => {
                if (p instanceof RegExp) {
                    for (const f of p.flags.split(''))
                        flags.add(f);
                }
                return typeof p === 'string'
                    ? regExpEscape(p)
                    : p === exports.GLOBSTAR
                        ? exports.GLOBSTAR
                        : p._src;
            });
            pp.forEach((p, i) => {
                const next = pp[i + 1];
                const prev = pp[i - 1];
                if (p !== exports.GLOBSTAR || prev === exports.GLOBSTAR) {
                    return;
                }
                if (prev === undefined) {
                    if (next !== undefined && next !== exports.GLOBSTAR) {
                        pp[i + 1] = '(?:\\/|' + twoStar + '\\/)?' + next;
                    }
                    else {
                        pp[i] = twoStar;
                    }
                }
                else if (next === undefined) {
                    pp[i - 1] = prev + '(?:\\/|' + twoStar + ')?';
                }
                else if (next !== exports.GLOBSTAR) {
                    pp[i - 1] = prev + '(?:\\/|\\/' + twoStar + '\\/)' + next;
                    pp[i + 1] = exports.GLOBSTAR;
                }
            });
            return pp.filter(p => p !== exports.GLOBSTAR).join('/');
        })
            .join('|');
        // need to wrap in parens if we had more than one thing with |,
        // otherwise only the first will be anchored to ^ and the last to $
        const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];
        // must match entire pattern
        // ending in a * or ** will make it less strict.
        re = '^' + open + re + close + '$';
        // can match anything, as long as it's not this.
        if (this.negate)
            re = '^(?!' + re + ').+$';
        try {
            this.regexp = new RegExp(re, [...flags].join(''));
            /* c8 ignore start */
        }
        catch (ex) {
            // should be impossible
            this.regexp = false;
        }
        /* c8 ignore stop */
        return this.regexp;
    }
    slashSplit(p) {
        // if p starts with // on windows, we preserve that
        // so that UNC paths aren't broken.  Otherwise, any number of
        // / characters are coalesced into one, unless
        // preserveMultipleSlashes is set to true.
        if (this.preserveMultipleSlashes) {
            return p.split('/');
        }
        else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
            // add an extra '' for the one we lose
            return ['', ...p.split(/\/+/)];
        }
        else {
            return p.split(/\/+/);
        }
    }
    match(f, partial = this.partial) {
        this.debug('match', f, this.pattern);
        // short-circuit in the case of busted things.
        // comments, etc.
        if (this.comment) {
            return false;
        }
        if (this.empty) {
            return f === '';
        }
        if (f === '/' && partial) {
            return true;
        }
        const options = this.options;
        // windows: need to use /, not \
        if (this.isWindows) {
            f = f.split('\\').join('/');
        }
        // treat the test path as a set of pathparts.
        const ff = this.slashSplit(f);
        this.debug(this.pattern, 'split', ff);
        // just ONE of the pattern sets in this.set needs to match
        // in order for it to be valid.  If negating, then just one
        // match means that we have failed.
        // Either way, return on the first hit.
        const set = this.set;
        this.debug(this.pattern, 'set', set);
        // Find the basename of the path by looking for the last non-empty segment
        let filename = ff[ff.length - 1];
        if (!filename) {
            for (let i = ff.length - 2; !filename && i >= 0; i--) {
                filename = ff[i];
            }
        }
        for (let i = 0; i < set.length; i++) {
            const pattern = set[i];
            let file = ff;
            if (options.matchBase && pattern.length === 1) {
                file = [filename];
            }
            const hit = this.matchOne(file, pattern, partial);
            if (hit) {
                if (options.flipNegate) {
                    return true;
                }
                return !this.negate;
            }
        }
        // didn't get any hits.  this is success if it's a negative
        // pattern, failure otherwise.
        if (options.flipNegate) {
            return false;
        }
        return this.negate;
    }
    static defaults(def) {
        return exports.minimatch.defaults(def).Minimatch;
    }
}
exports.Minimatch = Minimatch;
/* c8 ignore start */
var ast_js_2 = require("./ast.js");
Object.defineProperty(exports, "AST", { enumerable: true, get: function () { return ast_js_2.AST; } });
var escape_js_2 = require("./escape.js");
Object.defineProperty(exports, "escape", { enumerable: true, get: function () { return escape_js_2.escape; } });
var unescape_js_2 = require("./unescape.js");
Object.defineProperty(exports, "unescape", { enumerable: true, get: function () { return unescape_js_2.unescape; } });
/* c8 ignore stop */
exports.minimatch.AST = ast_js_1.AST;
exports.minimatch.Minimatch = Minimatch;
exports.minimatch.escape = escape_js_1.escape;
exports.minimatch.unescape = unescape_js_1.unescape;
//# sourceMappingURL=index.js.map