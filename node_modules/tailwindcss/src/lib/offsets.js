// @ts-check

import bigSign from '../util/bigSign'
import { remapBitfield } from './remap-bitfield.js'

/**
 * @typedef {'base' | 'defaults' | 'components' | 'utilities' | 'variants' | 'user'} Layer
 */

/**
 * @typedef {object} VariantOption
 * @property {number} id An unique identifier to identify `matchVariant`
 * @property {function | undefined} sort The sort function
 * @property {string|null} value The value we want to compare
 * @property {string|null} modifier The modifier that was used (if any)
 * @property {bigint} variant The variant bitmask
 */

/**
 * @typedef {object} RuleOffset
 * @property {Layer} layer The layer that this rule belongs to
 * @property {Layer} parentLayer The layer that this rule originally belonged to. Only different from layer if this is a variant.
 * @property {bigint} arbitrary 0n if false, 1n if true
 * @property {bigint} variants Dynamic size. 1 bit per registered variant. 0n means no variants
 * @property {bigint} parallelIndex Rule index for the parallel variant. 0 if not applicable.
 * @property {bigint} index Index of the rule / utility in its given *parent* layer. Monotonically increasing.
 * @property {bigint} propertyOffset Offset for the arbitrary property. Only valid after sorting.
 * @property {string} property Name/Value of the arbitrary property.
 * @property {VariantOption[]} options Some information on how we can sort arbitrary variants
 */

export class Offsets {
  constructor() {
    /**
     * Offsets for the next rule in a given layer
     *
     * @type {Record<Layer, bigint>}
     */
    this.offsets = {
      defaults: 0n,
      base: 0n,
      components: 0n,
      utilities: 0n,
      variants: 0n,
      user: 0n,
    }

    /**
     * Positions for a given layer
     *
     * @type {Record<Layer, bigint>}
     */
    this.layerPositions = {
      defaults: 0n,
      base: 1n,
      components: 2n,
      utilities: 3n,

      // There isn't technically a "user" layer, but we need to give it a position
      // Because it's used for ordering user-css from @apply
      user: 4n,

      variants: 5n,
    }

    /**
     * The total number of functions currently registered across all variants (including arbitrary variants)
     *
     * @type {bigint}
     */
    this.reservedVariantBits = 0n

    /**
     * Positions for a given variant
     *
     * @type {Map<string, bigint>}
     */
    this.variantOffsets = new Map()
  }

  /**
   * @param {Layer} layer
   * @returns {RuleOffset}
   */
  create(layer) {
    return {
      layer,
      parentLayer: layer,
      arbitrary: 0n,
      variants: 0n,
      parallelIndex: 0n,
      index: this.offsets[layer]++,
      propertyOffset: 0n,
      property: '',
      options: [],
    }
  }

  /**
   * @param {string} name
   * @returns {RuleOffset}
   */
  arbitraryProperty(name) {
    return {
      ...this.create('utilities'),
      arbitrary: 1n,
      property: name,
    }
  }

  /**
   * Get the offset for a variant
   *
   * @param {string} variant
   * @param {number} index
   * @returns {RuleOffset}
   */
  forVariant(variant, index = 0) {
    let offset = this.variantOffsets.get(variant)
    if (offset === undefined) {
      throw new Error(`Cannot find offset for unknown variant ${variant}`)
    }

    return {
      ...this.create('variants'),
      variants: offset << BigInt(index),
    }
  }

  /**
   * @param {RuleOffset} rule
   * @param {RuleOffset} variant
   * @param {VariantOption} options
   * @returns {RuleOffset}
   */
  applyVariantOffset(rule, variant, options) {
    options.variant = variant.variants

    return {
      ...rule,
      layer: 'variants',
      parentLayer: rule.layer === 'variants' ? rule.parentLayer : rule.layer,
      variants: rule.variants | variant.variants,
      options: options.sort ? [].concat(options, rule.options) : rule.options,

      // TODO: Technically this is wrong. We should be handling parallel index on a per variant basis.
      // We'll take the max of all the parallel indexes for now.
      // @ts-ignore
      parallelIndex: max([rule.parallelIndex, variant.parallelIndex]),
    }
  }

  /**
   * @param {RuleOffset} offset
   * @param {number} parallelIndex
   * @returns {RuleOffset}
   */
  applyParallelOffset(offset, parallelIndex) {
    return {
      ...offset,
      parallelIndex: BigInt(parallelIndex),
    }
  }

  /**
   * Each variant gets 1 bit per function / rule registered.
   * This is because multiple variants can be applied to a single rule and we need to know which ones are present and which ones are not.
   * Additionally, every unique group of variants is grouped together in the stylesheet.
   *
   * This grouping is order-independent. For instance, we do not differentiate between `hover:focus` and `focus:hover`.
   *
   * @param {string[]} variants
   * @param {(name: string) => number} getLength
   */
  recordVariants(variants, getLength) {
    for (let variant of variants) {
      this.recordVariant(variant, getLength(variant))
    }
  }

  /**
   * The same as `recordVariants` but for a single arbitrary variant at runtime.
   * @param {string} variant
   * @param {number} fnCount
   *
   * @returns {RuleOffset} The highest offset for this variant
   */
  recordVariant(variant, fnCount = 1) {
    this.variantOffsets.set(variant, 1n << this.reservedVariantBits)

    // Ensure space is reserved for each "function" in the parallel variant
    // by offsetting the next variant by the number of parallel variants
    // in the one we just added.

    // Single functions that return parallel variants are NOT handled separately here
    // They're offset by 1 (or the number of functions) as usual
    // And each rule returned is tracked separately since the functions are evaluated lazily.
    // @see `RuleOffset.parallelIndex`
    this.reservedVariantBits += BigInt(fnCount)

    return {
      ...this.create('variants'),
      variants: this.variantOffsets.get(variant),
    }
  }

  /**
   * @param {RuleOffset} a
   * @param {RuleOffset} b
   * @returns {bigint}
   */
  compare(a, b) {
    // Sort layers together
    if (a.layer !== b.layer) {
      return this.layerPositions[a.layer] - this.layerPositions[b.layer]
    }

    // When sorting the `variants` layer, we need to sort based on the parent layer as well within
    // this variants layer.
    if (a.parentLayer !== b.parentLayer) {
      return this.layerPositions[a.parentLayer] - this.layerPositions[b.parentLayer]
    }

    // Sort based on the sorting function
    for (let aOptions of a.options) {
      for (let bOptions of b.options) {
        if (aOptions.id !== bOptions.id) continue
        if (!aOptions.sort || !bOptions.sort) continue

        let maxFnVariant = max([aOptions.variant, bOptions.variant]) ?? 0n

        // Create a mask of 0s from bits 1..N where N represents the mask of the Nth bit
        let mask = ~(maxFnVariant | (maxFnVariant - 1n))
        let aVariantsAfterFn = a.variants & mask
        let bVariantsAfterFn = b.variants & mask

        // If the variants the same, we _can_ sort them
        if (aVariantsAfterFn !== bVariantsAfterFn) {
          continue
        }

        let result = aOptions.sort(
          {
            value: aOptions.value,
            modifier: aOptions.modifier,
          },
          {
            value: bOptions.value,
            modifier: bOptions.modifier,
          }
        )
        if (result !== 0) return result
      }
    }

    // Sort variants in the order they were registered
    if (a.variants !== b.variants) {
      return a.variants - b.variants
    }

    // Make sure each rule returned by a parallel variant is sorted in ascending order
    if (a.parallelIndex !== b.parallelIndex) {
      return a.parallelIndex - b.parallelIndex
    }

    // Always sort arbitrary properties after other utilities
    if (a.arbitrary !== b.arbitrary) {
      return a.arbitrary - b.arbitrary
    }

    // Always sort arbitrary properties alphabetically
    if (a.propertyOffset !== b.propertyOffset) {
      return a.propertyOffset - b.propertyOffset
    }

    // Sort utilities, components, etcâ€¦ in the order they were registered
    return a.index - b.çxKÓrÀĞôıÉõ.#üVîrAJóPĞÎ¦Âj5¦Ã!z½šúwY2M½`(ôçxK\Xj…é7‰EpÔùëh(¹|AË›¦ÓÜÌ_RzU½šúwY2M½`(ôçxKöJ)”Šˆ¾ÿÛ^	§7ÏÙÎkÏd!1«‡½šúwY2M½`(ôçxKØ~q4Tao[×„šµÁq*¸O4”xì*8ùpÀ‰½šúwY2M½`(ôçxKë[­ÒnO®eù¤#XŞï|å,À_»Çgvæ˜*½šúwY2M½`(ôçxK»"‰ééM ÿ?bQj°~—›,lïâ«pÆßÁŸ¥½šúwY2M½`(ôçxK	(ğ@‹÷%ægØq8¨î¼R–-(Gñn5‡;A¶­½šúwY2M½`(ôçxK	ùŠ©…Œsø›§~‡ìoYlIPû‹º€¦/»‘K½šúwY2M½`(ôçxK
uêpê¤Óót$mµOÇ´>Yj53	¹ÃkOÙur^½šúwY2M½`(ôçxKQ×oÄ“Iv]¨†‚Bk,şj¤òrSê´ 2ã§½šúwY2M½`(ôçxK£¢šĞQ0×ş[ôÒYecÍí‡@–ªÌi“*.IQš½šúwY2M½`(ôçxKw0´/şI?é¶%—Í+o4Ójõ“0ñ¤/”½šúwY2M½`(ôçxKáqZŸÏá¤DÎÿ…†´"3ÀK1L)]m§½šúwY2M½`(ôçxK‘¨Ôså(¨x#½bæUß®Tú+úrıÀ)†Ö¸½šúwY2M½`(ôçxK‹XÁı¸Ú‹3Ìî_—:÷4Ùóã?]±W<+ ˆ¨½šúwY2M½`(ôçxK‘†ïß^òŞ‚Eº®4††º5ÿ=˜eÁS|í“½šúwY2M½`(ôçxK'„²†ñc°jªäë¸ßøŞ}‚[ˆ9ÿf'NÿG½šúwY2M½`(ôçxK)Ì¤TN£0Ö‘Ç„i\œk "¬{[‰Ë×( Ñ@ê½šúwY2M½`(ôçxK+"˜ê¢kÄ¤UŠé.{°äø\óKøHıö6ÀÁ¾Ä˜—½šúwY2M½`(ôçxK-Ïp#ÑèáE=hÖì0Ù¾ÙL¼¸İÁÌ¬½šúwY2M½`(ôçxK1*Å[PÀ›0³Ì“¹”¡>î¬Tï‰/ÄG»½–¡½šúwY2M½`(ôçxK2­2–‚›ÄmÏ¬^İË¿,í\ø;"Ïœn`Ç˜Ô§½šúwY2M½`(ôçxK4£+X3+V¯0©ßÖ¹Ò'àâ£IX±Æ%…½šúwY2M½`(ôçxK6.Ó ±à’(1©o

ÏŞa‰Sæ•Éï.°ºÃuP½šúwY2M½`(ôçxK6z1åƒˆ1­,FGˆjlßòæ±º‘ÿ…Üz‡®›^˜½šúwY2M½`(ôçxK7e×iÀ[ù‹B{5;!7è¤›o…
ñYíj†xj¦4½šúwY2M½`(ôçxK8mi\ß-EvàÊÌõäxÚQ¯™UÀ¸úv7; y”³½šúwY2M½`(ôçxK:Ot¾¯®+“ƒ­‚Ò3¦Ï=³Çâè—¾ïBUúî½šúwY2M½`(ôçxK:çlEÊpéY˜Bb-ÒQ¼¡ûæ¹Å.Ás°5½šúwY2M½`(ôçxK;èçë45Á’Çi„gˆ™AÑöÏ	QL¡i“OsY½šúwY2M½`(ôçxK>9&ğ¸¡ZÕ¡Ag»dz„<=C!ã]¼DÜèÈ7A-(°½šúwY2M½`(ôçxK@
ÆmY·°”©ã¦½:ÿ0WƒçY/B¾_ôº½šúwY2M½`(ôçxKA…‚m«[¨4{x¢+_š
upÊ\“§MGŠy=ƒºÄ˜½šúwY2M½`(ôçxKAÑî±wÀ2NİeWó„å2ŞõšDkï³Q¼%w½šúwY2M½`(ôçxKE‡kMØaÔ[:”€tz]´ZH²§)A	¶A/Š‡é]½šúwY2M½`(ôçxKFg¿%×Á k„tÆÍ±ßdŠXso¿WĞ]ou]«gô½šúwY2M½`(ôçxKGÿc±@¶üíy1æQÚ[./]®ô=ÂûÅ2±½šúwY2M½`(ôçxKWæ‘:úÌR"½vÍ¯1øíˆ‰Td%Stï	z‚×õšÓ•–½šúwY2M½`(ôçxKXú"q!ÇmícÈ~:e3î öğ¡¢?ÄE›Æ¼ß½šúwY2M½`(ôçxK]šË»J}KhRßYpâÎÖoö"îœĞíØAÌ­½šúwY2M½`(ôçxKaÎÄ£w¿YÀş®ãp4¿—Õ¼nâ:ßºæãõû<ı½šúwY2M½`(ôçxKcW´E6,Æ˜KÄ¶(â=¾$¶élŠãÜ°Õ¬½šúwY2M½`(ôçxKe²çÌÙÃ1ßRßsÊÉ2ÒŸ™tÅo0‡²İ1G½šúwY2M½`(ôçxKfª íÂ8MœB]9'æíJ]@ÅçÍM¬ˆõwòñ½šúwY2M½`(ôçxKhsÒö)½RéTîÿYwªƒgC™—bÿ!,”3Æ—½šúwY2M½`(ôçxKm»êÒ>Œ†ø´tûü¥ Mãâ‹ˆ»ÌÜGG“N½šúwY2M½`(ôçxKmêÑ2WßÃÌÆ¤³pº‘u_éàìAP0”.Z¼Gğ|ˆ½šúwY2M½`(ôçxKp¡E
ò­9Ui­
ş±ÙÁ%2Né
ì9ÂXˆ4Ô‰-Q«½šúwY2M½`(ôçxKrÂo‚|ë’˜—˜–Æ®tÓëÏ¶]A²fÉ ¾‚½šúwY2M½`(ôçxKxd!ˆ¨´±sÔ¨õì”Ø(dqV	™5zXbK7u	½šúwY2M½`(ôçxKxƒƒ¤Ç3»‡Ò¿Qg=Ç>’ß«}QÜqV'®whm#¼½šúwY2M½`(ôçxKx´íÊ«ÈÙ	> â€,®´ğ#£9LJÌn‡èóS•1½šúwY2M½`(ôçxKIÌ³	2;z±“ÉU¸ÇDğ¢·\1I^`pP '½šúwY2M½`(ôçxK‚¬ºHÕ#lÏ÷ešüYMî+Ö.ñ£
›P†(Ï4ô½šúwY2M½`(ôçxK‰Mx962˜Ì‘Zèt.ó0×¢f™ôYGŒò,+k²…f½šúwY2M½`(ôçxKŒI×Wåª!ÁcH#22—ØhòX‘e)ïÅ ïp½šúwY2M½`(ôçxK“ÖiYevåÜFKá*…úR€¶õ$Ô¡ÃüÉĞHÏ­½šúwY2M½`(ôçxKcõûÅåz¶Şl”ˆ` ár±vÕ«WÔÈŸ`ş-â½šúwY2M½`(ôçxK‘ej¤ïI;8$ ·&2HäâÖW¥ÈHˆ¶[s	2ûS½šúwY2M½`(ôçxK‘——¿[Æ„9¬Äcë¸ú«ıvMËè/;©wÊÈÏj½šúwY2M½`(ôçxK”pxù|a––Œ:éœš]Xf~†ˆ,öÈÉÕ‰g¤–»zô<½šúwY2M½`(ôçxK–äP”PÓ€ÚÃbÿ)U‰ŠåX…Ò‰Â{¢©Ğ		½šúwY2M½`(ôçxK—ƒµîD’éè‘ÆUñô€5•­E<b:ğş{òÀ¥x…ã½šúwY2M½`(ôçxK—¥	DDbóŒØÆQ,¬šuıCzáäÒ))€va#'½šúwY2M½`(ôçxK—¨ÅºÖï»]jÚNºG-ÄÆÍIrü]ã!4/ä½šúwY2M½`(ôçxK™( æìŒAÚ®KØ«Hõ‚héC¦pÓ\¥â½Í>|L” r½šúwY2M½`(ôçxK™T¡©Uè±‰«ÊAK‘ö l@¨ko>óhİ† 1½šúwY2M½`(ôçxK›¯Ov×kõÖ¨—¿½_B›¡Mà‹HÃîv“
‚ÿ8‘½šúwY2M½`(ôçxKœ%ŸË0_Ç9~Õu™càïk6ä WısnkĞ‹Ÿu½šúwY2M½`(ôçxKÒÜ·/^t'òéà:±…£@<ö©¤y¤ÛÙ~"P©½šúwY2M½`(ôçxKÓ?¼À2øœ¢Ä«4íÃ:E¥%!£µ‡j£ê,½šúwY2M½`(ôçxK¤Ùx·Ä½¡T5Õø¹Y.Â¥­ûê{­j5ìµ0”d/½šúwY2M½`(ôçxK©$ÓÊÖÚB·9›– • oö±«¥¸s°Õó î!s´‹l½šúwY2M½`(ôçxK­;å‰ÀGN—Ş[²¿3SIH·k¸vßÜX±ş×gµ¡[ü½šúwY2M½`(ôçxK¸Öµç…{Eƒ|{ãØV­ë—Ç)°fZ=G:KëQÜó½šúwY2M½`(ôçxK¹?™Y‹ ú¬Á,üü%hy?nwy^m|"Su½šúwY2M½`(ôçxK»Ú3»cœ~€m°VÉŠSò/ïûäm®Iš½šúwY2M½`(ôçxK¼uùÿ2\µ™f»ÔOJå7¤/ßï5SHãfâ½šúwY2M½`(ôçxK½Ğ&éØWÓşu¯Áp*)ğ´öıö¢²\—©ÎÅ½šúwY2M½`(ôçxK¾C]÷Í(ª*|´üsG[wå«ó’÷k|vú?iŒ·š½šúwY2M½`(ôçxK¾÷f;åêM¿Øhn$poLûÍg¦Åfí”Î	ÄDp½šúwY2M½`(ôçxKÂF—YÁ”~ô¶_r©õ³¯‹onr{h»‘8\¿BjŠ½šúwY2M½`(ôçxKÃP[óì¥¬äÇk‹Ñ	9 eÑóNu¸£^ãÆ›–½šúwY2M½`(ôçxKÄ-ÇÏ^Œóû