"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    formatVariantSelector: function() {
        return formatVariantSelector;
    },
    eliminateIrrelevantSelectors: function() {
        return eliminateIrrelevantSelectors;
    },
    finalizeSelector: function() {
        return finalizeSelector;
    },
    handleMergePseudo: function() {
        return handleMergePseudo;
    }
});
const _postcssselectorparser = /*#__PURE__*/ _interop_require_default(require("postcss-selector-parser"));
const _unesc = /*#__PURE__*/ _interop_require_default(require("postcss-selector-parser/dist/util/unesc"));
const _escapeClassName = /*#__PURE__*/ _interop_require_default(require("../util/escapeClassName"));
const _prefixSelector = /*#__PURE__*/ _interop_require_default(require("../util/prefixSelector"));
const _pseudoElements = require("./pseudoElements");
const _splitAtTopLevelOnly = require("./splitAtTopLevelOnly");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/** @typedef {import('postcss-selector-parser').Root} Root */ /** @typedef {import('postcss-selector-parser').Selector} Selector */ /** @typedef {import('postcss-selector-parser').Pseudo} Pseudo */ /** @typedef {import('postcss-selector-parser').Node} Node */ /** @typedef {{format: string, respectPrefix: boolean}[]} RawFormats */ /** @typedef {import('postcss-selector-parser').Root} ParsedFormats */ /** @typedef {RawFormats | ParsedFormats} AcceptedFormats */ let MERGE = ":merge";
function formatVariantSelector(formats, { context , candidate  }) {
    var _context_tailwindConfig_prefix;
    let prefix = (_context_tailwindConfig_prefix = context === null || context === void 0 ? void 0 : context.tailwindConfig.prefix) !== null && _context_tailwindConfig_prefix !== void 0 ? _context_tailwindConfig_prefix : "";
    // Parse the format selector into an AST
    let parsedFormats = formats.map((format)=>{
        let ast = (0, _postcssselectorparser.default)().astSync(format.format);
        return {
            ...format,
            ast: format.respectPrefix ? (0, _prefixSelector.default)(prefix, ast) : ast
        };
    });
    // We start with the candidate selector
    let formatAst = _postcssselectorparser.default.root({
        nodes: [
            _postcssselectorparser.default.selector({
                nodes: [
                    _postcssselectorparser.default.className({
                        value: (0, _escapeClassName.default)(candidate)
                    })
                ]
            })
        ]
    });
    // And iteratively merge each format selector into the candidate selector
    for (let { ast  } of parsedFormats){
        [formatAst, ast] = handleMergePseudo(formatAst, ast);
        // 2. Merge the format selector into the current selector AST
        ast.walkNesting((nesting)=>nesting.replaceWith(...formatAst.nodes[0].nodes));
        // 3. Keep going!
        formatAst = ast;
    }
    return formatAst;
}
/**
 * Given any node in a selector this gets the "simple" selector it's a part of
 * A simple selector is just a list of nodes without any combinators
 * Technically :is(), :not(), :has(), etcБ─╕ can have combinators but those are nested
 * inside the relevant node and won't be picked up so they're fine to ignore
 *
 * @param {Node} node
 * @returns {Node[]}
 **/ function simpleSelectorForNode(node) {
    /** @type {Node[]} */ let nodes = [];
    // Walk backwards until we hit a combinator node (or the start)
    while(node.prev() && node.prev().type !== "combinator"){
        node = node.prev();
    }
    // Now record all non-combinator nodes until we hit one (or the end)
    while(node && node.type !== "combinator"){
        nodes.push(node);
        node = node.next();
    }
    return nodes;
}
/**
 * Resorts the nodes in a selector to ensure they're in the correct order
 * Tags go before classes, and pseudo classes go after classes
 *
 * @param {Selector} sel
 * @returns {Selector}
 **/ function resortSelector(sel) {
    sel.sort((a, b)=>{
        if (a.type === "tag" && b.type === "class") {
            return -1;
        } else if (a.type === "class" && b.type === "tag") {
            return 1;
        } else if (a.type === "class" && b.type === "pseudo" && b.value.startsWith("::")) {
            return -1;
        } else if (a.type === "pseudo" && a.value.startsWith("::") && b.type === "class") {
            return 1;
        }
        return sel.index(a) - sel.index(b);
    });
    return sel;
}
function eliminateIrrelevantSelectors(sel, base) {
    let hasClassesMatchingCandidate = false;
    sel.walk((child)=>{
        if (child.type === "class" && child.value === base) {
            hasClassesMatchingCandidate = true;
            return false // Stop walking
            ;
        }
    });
    if (!hasClassesMatchingCandidate) {
        sel.remove();
    }
// We do NOT recursively eliminate sub selectors that don't have the base class
// as this is NOT a safe operation. For example, if we have:
// `.space-x-2 > :not([hidden]) ~ :not([hidden])`
// We cannot remove the [hidden] from the :not() because it would change the
// meaning of the selector.
// TODO: Can we do this for :matches, :is, and :where?
}
function finalizeSelector(current, formats, { context , candidate , base  }) {
    var _context_tailwindConfig;
    var _context_tailwindConfig_separator;
    let separator = (_context_tailwindConfig_separator = context === null || context === void 0 ? void 0 : (_context_tailwindConfig = context.tailwindConfig) === null || _context_tailwindConfig === void 0 ? void 0 : _context_tailwindConfig.separator) !== null && _context_tailwindConfig_separator !== void 0 ? _context_tailwindConfig_separator : ":";
    // Split by the separator, but ignore the separator inside square brackets:
    //
    // E.g.: dark:lg:hover:[paint-order:markers]
    //           Б■╛  Б■╛     Б■╛            Б■╛
    //           Б■┌  Б■┌     Б■┌            Б∙╟Б■─Б■─ We will not split here
    //           Б∙╟Б■─Б■─Б■╢Б■─Б■─Б■─Б■─Б■─Б■╢Б■─Б■─Б■─Б■─Б■─Б■─Б■─Б■─Б■─Б■─Б■─Б■─Б■─Б■─Б■─ We will split here
    //
    base = base !== null && base !== void 0 ? base : (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(candidate, separator).pop();
    // Parse the selector into an AST
    let selector = (0, _postcssselectorparser.default)().astSync(current);
    // Normalize escaped classes, e.g.:
    //
    // The idea would be to replace the escaped `base` in the selector with the
    // `format`. However, in css you can escape the same selector in a few
    // different ways. This would result in different strings and therefore we
    // can't replace it properly.
    //
    //               base: bg-[rgb(255,0,0)]
    //   base in selector: bg-\\[rgb\\(255\\,0\\,0\\)\\]
    //       escaped base: bg-\\[rgb\\(255\\2c 0\\2c 0\\)\\]
    //
    selector.walkClasses((node)=>{
        if (node.raws && node.value.includes(base)) {
            node.raws.value = (0, _escapeClassName.default)((0, _unesc.default)(node.raws.value));
        }
    });
    // Remove extraneous selectors that do not include the base candidate
    selector.each((sel)=>eliminateIrrelevantSelectors(sel, base));
    // If ffter eliminating irrelevant selectors, we end up with nothing
    // Then the whole "rule" this is associated with does not need to exist
    // We use `null` as a marker value for that case
    if (selector.length === 0) {
        return null;
    }
    // If there are no formats that means there were no variants added to the candidate
    // so we can just return the selector as-is
    let formatAst = Array.isArray(formats) ? formatVariantSelector(formats, {
        context,
        candidate
    }) : formats;
    if (formatAst === null) {
        return selector.toString();
    }
    let simpleStart = _postcssselectorparser.default.comment({
        value: "/*__simple__*/"
    });
    let simpleEnd = _postcssselectorparser.default.comment({
    H▀D$HL█L\  гD$8ЪЪ ─E3игD$0   ╨L  H┴D$(H┐d$  ХhЩЪЪH┐дHцллллллл╧   м)цллллллллH┐Л(HЪ╣U  D  ┘юtH┐д(цлH▀L$(╨&	  ХcЪЪЪлллллллH┐Л(HЪ┘V  D  ┘юtH┐д(цлH▀L$(╨0	  Х3ЪЪЪлллллллH┐Л(H▀	H┘иtХ©ЪЪЪ░H┐д(цллллллллл@SH┐Л H▀▀  3шH┘юuHH▀}▀  H┘юuH█≥[  HЪZU  D  H┴^▀  H█≈[  H▀хHЪMU  D  H┴я┼  H┘юtЪЖW  ┼ь┼цH┐д [цллллллллллллллллллллH┴\$H┴t$WH┐Л H▀З┼  3шH▀ЗH▀ЯH┘юuHH▀Н┼  H┘юuH█
[  HЪкT  D  H┴о┼  H█([  H▀хHЪ╬T  D  H┴╙┼  H┘юtH▀вH▀нЪaW  ▀ьH▀t$8▀цH▀\$0H┐д _цлллллллллH┴\$H┴l$VWATAVAWH│ЛP  H▀Л┌  H3дH┴└$@  H╦       юI▀ыL▀бH▀ЫL┘х┘╣  H█D$0╨  L+юH█L$0E3ДA█t$H█┌ЗЧЪH┘юtA╥f┘юtf┴H┐аH+жuчH█AЧH┘рL█sZ  HEаH█L$0fD┴ ХуЦЪЪL▀СгD$(  D▀фIаН│ЦЪЪЪD┴d$ L█L$0▀сDGц3иHЪ8T  D  L▀ЬH┘юt4H▀/H┘Мt$HЪТR  D  H▀м▀ьХmЩЪЪ▀кHЪЛR  D  L┴?A▀эКХ>КЪЪ▀ь┘шy╨┘   H▀▄$x  D▀кХgЭЪЪ▀цИ⌠   L█иY  H█L$0Х+ЦЪЪE┘ЖгD$(  L█L$0D┴d$ AEЖA▀жD▀ф3иHЪ≈S  D  H▀ХH┘юt6H▀wH┘Жt$HЪRR  D  H▀н▀ьХкЭЪЪ▀кHЪJR  D  H┴oA▀эКХ⌡ЙЪЪ▀ь┘шy
╨┴   ИXЪЪЪ3юH▀▄$@  H3лХM9  L█°$P  I▀[8I▀k@I▀ЦA_A^A\_^цлХ[ЭЪЪлллллллH┴t$WH┐Л H▀РH▀Ы3рHЪS  D  ┐ЬЪu╨∙   H▀L$(Х·ШЪЪИ/  ┘юt=  t
╨√   И  ┐d$@ ╨   H▀о┘юu[L█D$@HЪёR  D  ┘юu╨·   К╞ЪD$@E3юH▀оA█PHЪ~R  D  ┘юuHЪ>Q  D  =*  └■   ╨ё   И≥   ┐d$H L█D$HHЪCR  D  ┘юu
╨╜   ИLЪЪЪ┐|$H t╨╝   КgE3юH▀оA█PHЪR  D  ┘юuHHЪяP  D  =*  u53рH▀оHЪ	R  D  ┐ЬЪu
╨╢   ИЯЧЪЪ┘юt╨╣   К▀D$@┴3юК╨╠   H▀L$(A╧ЪЪ ─Х3ЗЪЪ╦ЪЪ ─H▀t$0H┐д _цллллллл▀ацлллллллллH┴\$H┴l$H┴t$WATAUAVAWH┐Л D┴AL█y▀BL█q ┴AL█i8E3иH▀ЫM┴H┐нЪ╥B8L▀Бf┴A┼┬AM┴H▀┌─   H┴A(H▀┌┬   H┴A0M┴M H▀J0H┘иu█AКH▀фHЪюD8uВHЪюH▀RxH┘рu█JКH▀нHЪаD8
uВHЪаM▀D$M┘юuA█PКH▀жHЪбfE9PuЖH█U   H█
HьL9O@t
H9_H┐┘   HЪоO  D  L▀ц╨   H▀хHЪюO  D  E3иH▀ХL9┘  t"HЪ²O  D  H▀хH▀уH▀К└  Ъ┘R  E3иH┘Мt,HЪvO  D  L▀G@3рH▀хHЪYO  D  E3иH┴o@H┴_HH▀_@H┘ш└а   H▀WHM▀D$0H█,H;щt9M┘юt4E8t/H▀ЧHЪгE88uВHЪгH;вrL▀оH▀кХУщЪЪE3иM┘ЪtI┴HъКM┘ЪtM┴M▀D$xH;щt9M┘юt4E8t/HЪфE80uВH▀уHЪфH+сH;жrL▀нH▀кХ╖щЪЪM┘ЖtI┴HчКM┘ЖtM┴M▀D$M▀мH▀уH▀кХЁ
  H+Х3рL▀еH▀хХQC  H▀\$PH▀l$XH▀t$`H┐д A_A^A]A\_цллллллллллH┴\$H┴l$H┴t$WH┐Л H▀Y3М╥A H▀ЫH█4─HаФHСH;чt<H┐ц@HЪ N  D  L▀3рH▀хHЪN  D  H┴+H┴kH█[PH█CюH;фuлH▀_HЪХM  D  L▀ц3рH▀хHЪлM  D  H▀\$0H▀t$@┴o H┴oH▀l$8H┐д _цлллллллH▀дH┴XH┴hH┴pH┴x ATAVAWH┐Л H▀YE3Ъ▀iL▀РH▀ЯA╪P   H┘ш┘┤   ┘Мt~HЪeM  D  █SA╦░  H▀хHЪUM  D  L9=║┌  H▀ЬH▀ьtHЪ2M  D  H▀хH▀сH▀─┌  ЪP  H┴~H┘Ъt#H█┤░  гF    H;ЬtfD┴'IЭH;ЬuТH▀^H┘шtt┘Мt4╥F H█─HаАHкH;ыt ▀VH┐ц9SЭvA▀F9tHIэH█CЬH;аuГ╥F"3р╥N ЪюВЯH▀FA╦   f┴V"ПDа ╥F"AЪюI▀жH█─HаАHNХ╫ШЪЪH▀\$@H▀l$HH▀t$PH▀|$XH┐д A_A^A\цллллллллллH┴\$WH┐Л H▀=K│  3шH┘Ъ└■   H9_u%H▀H█T$8H!\$8Х   ┘юxH9_u	H▀D$8H┴GH▀GH█H HВьHЪH#ЫtVHЪSL  D  D▀юD▀хH╦млллллллIВАHаЙH█▓HиL+аJ▀\гК	D9t,H▀[H┘шuРH┘шtH┐{ uH█OH┴KH▀цH▀\$0H┐д _цлH┐цКвлллллллH┴\$H┴l$H┴t$WH┐Л 2юAф  I▀ИI▀ЬH▀РH▀ыH┘р└╟   H▀RХхЪЪЪH▀V H┘р└    ┐: u╦   Паz  Ъю┴┐{H uCHРJРKXH┐иЪL█/H▀аC`РJРKpHЪю─< uВHЬI▀бH+гH┐Ь~7ф\HЪгL▀BHЪаA─< uЖHЪаL+вI;йI▀зI▀рHBыH▀оL▀кХ■ыЪЪфD;Ъ ╟H▀\$0H▀l$8H▀t$@H┐д _цллллллллллллллллллллH▀дH┴XH┴hH┴pH┴x AVH┐Л ф @2МH▀┼  M▀ПH▀РH▀ЫH┘шtEHЪ╔J  D  D▀хD▀пH╦млллллллIВБHаЙH█▓HиL+иJ▀кКD9└ч   H▀[H┘шuН3шH┘шtDH┐; t>@┬.M▀нH▀L▀фH▀оХ^ЧЪЪ└юtH┴w@H▀H▀KH▀вH▀H▀ ЪюL  H▀[@
ХH┘шuАH▀У~  H┘юtH▀в@┼мЪ°L  HЪЩI  D  ▀n  ;хt@╧   Паa  Ъа┐Ы}%┴P  ХЩЪЪH┘юtH▀вH▀хХ╚ШЪЪг1      ПЪ.  H▀\$0H▀l$8H▀t$@H▀|$HH┐д A^цлH┐цИ$ЪЪЪлллллллллH┴\$UVWAVAWH█╛$─ЧЪЪH│Л─  H▀╬w  H3дH┴┘p  L▀ЗH▀ыH┐" HЪKI  D  D▀хH┴\$(гD